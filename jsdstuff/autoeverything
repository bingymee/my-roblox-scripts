-- ROBLOX LOCAL SCRIPT
-- UPDATED: Scrollable UI, Fixed Overlapping Tabs (TransitionID), 3 M1 Limit, Prediction
-- Features: Auto-Block, Auto-Punch, Dash, Cam Lock, Cache

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local Player = Players.LocalPlayer

-- =================================================================================
-- 1. CONFIG & DATABASE
-- =================================================================================

local m1Database = {
	-- Gojo
	["127314304761047"] = true, ["77891317857963"] = true, ["84446039611604"] = true, ["114159183912233"] = true,
	-- Esper
	["101101710876334"] = true, ["124127341057164"] = true, ["100901440555342"] = true, ["85853405255331"] = true,
	-- Mob
	["85692420698843"] = true, ["75662531587920"] = true, ["130769245088771"] = true, ["103631040324206"] = true,
	-- Chara
	["107867399798954"] = true, ["134486729011918"] = true, ["77034551070437"] = true, ["83150158223563"] = true,
	-- Godly
	["136031609325321"] = true, ["120212532321192"] = true, ["74960987180381"] = true, ["122575871777232"] = true,
	-- Blade
	["81483118494377"] = true, ["123762736246826"] = true, ["78443495730840"] = true, ["92893455375455"] = true,
	-- Kratos M1s
	["130573375727993"] = true, ["114333120271557"] = true, ["131141291261313"] = true, ["70618047941591"] = true,
	["110804273799167"] = true, ["124509785398074"] = true, ["88637553004334"] = true, ["113533567296840"] = true,
}

local dashStarts = {
	["78290593213759"] = true, -- Gojo
	["81171550723416"] = true, -- Esper
	["16900584124"] = true,    -- Mob
	["107027465005454"] = true, -- Chara
	["104708203440312"] = true, -- Kratos Axe
	["83008536875803"] = true,  -- Kratos Fist
	["102141442579104"] = true, -- Godly
	["134054487113051"] = true, -- Blade
	["113533567296840"] = true, -- Extra Check
}

local dashEnds = {
	["82190646305055"] = true, -- Gojo
	["136991308458459"] = true, -- Esper
	["16897565629"] = true,    -- Mob
	["72484334716316"] = true,  -- Chara
	["77242304295828"] = true,  -- Kratos Axe
	["89684566192164"] = true,  -- Kratos Fist
	["99230829853381"] = true,  -- Godly
	["74672338436170"] = true,  -- Blade
}

local activeCharacters = {} 
local processedTracks = {}

-- Combo State
local localComboCount = 0
local lastLocalPunchTime = 0
local comboCooldownActive = false

-- Dash Animation
local dashAnimRight = Instance.new("Animation"); dashAnimRight.AnimationId = "rbxassetid://16482641019"
local dashAnimLeft = Instance.new("Animation"); dashAnimLeft.AnimationId = "rbxassetid://16482659401"

-- CONTENT HEIGHT CONFIG (For Scrollbar)
-- These numbers determine how far you can scroll on each tab
local TAB_HEIGHTS = {
	Block = 550,
	Dash = 550,
	Punch = 500,
	Misc = 400
}

-- =================================================================================
-- 2. REMOTE HANDLING
-- =================================================================================

local Remote = nil
task.spawn(function()
	local success, result = pcall(function()
		return Player:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("AttackInput")
	end)
	if success then Remote = result end
end)

local function sendRemote(action, state)
	if not Remote then return end
	Remote:FireServer(action, state)
end

-- =================================================================================
-- 3. UI CONSTRUCTION
-- =================================================================================

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ModernCombatUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = Player:WaitForChild("PlayerGui")

-- Tooltip
local TooltipFrame = Instance.new("Frame")
TooltipFrame.Name = "Tooltip"
TooltipFrame.Size = UDim2.new(0, 200, 0, 0)
TooltipFrame.AutomaticSize = Enum.AutomaticSize.Y
TooltipFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
TooltipFrame.BorderSizePixel = 0
TooltipFrame.Visible = false
TooltipFrame.ZIndex = 200 
TooltipFrame.Parent = ScreenGui

local TTStroke = Instance.new("UIStroke", TooltipFrame)
TTStroke.Color = Color3.fromRGB(60, 60, 70)
TTStroke.Thickness = 1
local TTCorner = Instance.new("UICorner", TooltipFrame)
TTCorner.CornerRadius = UDim.new(0, 6)
local TTLabel = Instance.new("TextLabel", TooltipFrame)
TTLabel.Size = UDim2.new(1, -10, 0, 0)
TTLabel.Position = UDim2.new(0, 5, 0, 5)
TTLabel.AutomaticSize = Enum.AutomaticSize.Y
TTLabel.BackgroundTransparency = 1
TTLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9)
TTLabel.Font = Enum.Font.Gotham
TTLabel.TextSize = 11
TTLabel.TextWrapped = true
TTLabel.TextXAlignment = Enum.TextXAlignment.Left
TTLabel.ZIndex = 201
TTLabel.Parent = TooltipFrame
local TTPadding = Instance.new("UIPadding", TooltipFrame)
TTPadding.PaddingBottom = UDim.new(0, 5)

-- Main Window (Fixed Height, Scrollable Content)
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 280, 0, 450) -- Fixed height window
MainFrame.Position = UDim2.new(0.1, 0, 0.2, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.ClipsDescendants = true
MainFrame.Parent = ScreenGui

local MainCorner = Instance.new("UICorner", MainFrame)
MainCorner.CornerRadius = UDim.new(0, 10)
local MainStroke = Instance.new("UIStroke", MainFrame)
MainStroke.Color = Color3.fromRGB(50, 50, 60)
MainStroke.Thickness = 2

-- Drag Logic
local dragging, dragInput, dragStart, startPos
MainFrame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true; dragStart = input.Position; startPos = MainFrame.Position
		input.Changed:Connect(function() if input.UserInputState == Enum.UserInputState.End then dragging = false end end)
	end
end)
MainFrame.InputChanged:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then dragInput = input end end)
UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		local delta = input.Position - dragStart
		MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

local function tween(obj, info, props) TweenService:Create(obj, TweenInfo.new(unpack(info)), props):Play() end

local function registerTooltip(button, text)
	button.MouseEnter:Connect(function()
		TTLabel.Text = text
		TooltipFrame.Visible = true
		TooltipFrame.BackgroundTransparency = 1
		TTLabel.TextTransparency = 1
		tween(TooltipFrame, {0.2}, {BackgroundTransparency = 0.1})
		tween(TTLabel, {0.2}, {TextTransparency = 0})
	end)
	button.MouseMoved:Connect(function()
		local m = UserInputService:GetMouseLocation()
		TooltipFrame.Position = UDim2.fromOffset(m.X + 15, m.Y + 15)
	end)
	button.MouseLeave:Connect(function() TooltipFrame.Visible = false end)
end

local function createInput(parent, text, default, yPos)
	local Container = Instance.new("Frame", parent)
	Container.Size = UDim2.new(0.9, 0, 0, 30)
	Container.Position = UDim2.new(0.5, 0, 0, yPos)
	Container.AnchorPoint = Vector2.new(0.5, 0.5)
	Container.BackgroundTransparency = 1
	Container.ZIndex = 2
	Container:SetAttribute("OrgSize", Container.Size)

	local Label = Instance.new("TextLabel", Container)
	Label.Text = text
	Label.Size = UDim2.new(0.5, 0, 1, 0)
	Label.BackgroundTransparency = 1
	Label.TextColor3 = Color3.fromRGB(200, 200, 200)
	Label.TextXAlignment = Enum.TextXAlignment.Left
	Label.Font = Enum.Font.GothamMedium
	Label.TextSize = 12
	Label.ZIndex = 2

	local Box = Instance.new("TextBox", Container)
	Box.Text = default
	Box.Size = UDim2.new(0.45, 0, 1, 0)
	Box.Position = UDim2.new(0.55, 0, 0, 0)
	Box.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
	Box.TextColor3 = Color3.fromRGB(100, 255, 120)
	Box.Font = Enum.Font.Code
	Box.TextSize = 12
	Box.ZIndex = 2
	
	local Corner = Instance.new("UICorner", Box); Corner.CornerRadius = UDim.new(0, 6)
	return Box, Container
end

local function createToggle(parent, text, yPos)
	local Btn = Instance.new("TextButton", parent)
	Btn.Text = text
	Btn.Size = UDim2.new(0.9, 0, 0, 35)
	Btn.Position = UDim2.new(0.5, 0, 0, yPos)
	Btn.AnchorPoint = Vector2.new(0.5, 0.5)
	Btn.BackgroundColor3 = Color3.fromRGB(180, 60, 60)
	Btn.TextColor3 = Color3.new(1, 1, 1)
	Btn.Font = Enum.Font.GothamBold
	Btn.TextSize = 14
	Btn.ZIndex = 2
	Btn:SetAttribute("OrgSize", Btn.Size)
	Btn:SetAttribute("BaseColor", Btn.BackgroundColor3) 
	local Corner = Instance.new("UICorner", Btn); Corner.CornerRadius = UDim.new(0, 6)
	
	-- Hover Effect
	Btn.MouseEnter:Connect(function()
		local curr = Btn.BackgroundColor3
		tween(Btn, {0.2, Enum.EasingStyle.Quad}, {BackgroundColor3 = Color3.new(math.min(curr.R+0.1,1), math.min(curr.G+0.1,1), math.min(curr.B+0.1,1))})
	end)
	Btn.MouseLeave:Connect(function()
		tween(Btn, {0.2, Enum.EasingStyle.Quad}, {BackgroundColor3 = Btn:GetAttribute("BaseColor")})
	end)
	
	return Btn
end

-- =================================================================================
-- 4. PAGE CONTENT & SCROLLING
-- =================================================================================

local TabFrame = Instance.new("Frame", MainFrame)
TabFrame.Size = UDim2.new(1, -10, 0, 40)
TabFrame.Position = UDim2.new(0.5, 0, 0, 5)
TabFrame.AnchorPoint = Vector2.new(0.5, 0)
TabFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
TabFrame.ZIndex = 10
local TabCorner = Instance.new("UICorner", TabFrame); TabCorner.CornerRadius = UDim.new(0, 8)

local function createTabBtn(text, xOrder)
	local btn = Instance.new("TextButton", TabFrame)
	btn.Size = UDim2.new(0.25, 0, 1, 0)
	btn.Position = UDim2.new(0.25 * (xOrder-1), 0, 0, 0)
	btn.Text = text
	btn.BackgroundTransparency = 1
	btn.TextColor3 = Color3.fromRGB(150,150,150)
	btn.Font = Enum.Font.GothamBold
	btn.TextSize = 11
	btn.ZIndex = 11
	return btn
end

local BlockTabBtn = createTabBtn("BLOCK", 1); BlockTabBtn.TextColor3 = Color3.new(1,1,1)
local DashTabBtn = createTabBtn("DASH", 2)
local PunchTabBtn = createTabBtn("PUNCH", 3)
local MiscTabBtn = createTabBtn("MISC", 4)

local TabIndicator = Instance.new("Frame", TabFrame)
TabIndicator.Size = UDim2.new(0.25, -4, 0, 3)
TabIndicator.Position = UDim2.new(0, 2, 1, -3)
TabIndicator.BackgroundColor3 = Color3.fromRGB(80, 200, 120)
TabIndicator.BorderSizePixel = 0
TabIndicator.ZIndex = 12
local IndCorner = Instance.new("UICorner", TabIndicator); IndCorner.CornerRadius = UDim.new(1, 0)

-- SCROLLING CONTAINER
local ScrollContainer = Instance.new("ScrollingFrame", MainFrame)
ScrollContainer.Size = UDim2.new(1, 0, 1, -50)
ScrollContainer.Position = UDim2.new(0, 0, 0, 50)
ScrollContainer.BackgroundTransparency = 1
ScrollContainer.BorderSizePixel = 0
ScrollContainer.ScrollBarThickness = 4
ScrollContainer.ScrollBarImageColor3 = Color3.fromRGB(80, 200, 120)
ScrollContainer.ClipsDescendants = true -- Ensures elements hide when scrolled/switched
ScrollContainer.CanvasSize = UDim2.new(0, 0, 0, 550) -- Dynamic

-- Pages
local BlockPage = Instance.new("Frame", ScrollContainer); BlockPage.Size = UDim2.new(1, 0, 1, 0); BlockPage.BackgroundTransparency = 1; BlockPage.Visible = true; BlockPage.Name = "BlockPage"
local DashPage = Instance.new("Frame", ScrollContainer); DashPage.Size = UDim2.new(1, 0, 1, 0); DashPage.BackgroundTransparency = 1; DashPage.Visible = false; DashPage.Name = "DashPage"
local PunchPage = Instance.new("Frame", ScrollContainer); PunchPage.Size = UDim2.new(1, 0, 1, 0); PunchPage.BackgroundTransparency = 1; PunchPage.Visible = false; PunchPage.Name = "PunchPage"
local MiscPage = Instance.new("Frame", ScrollContainer); MiscPage.Size = UDim2.new(1, 0, 1, 0); MiscPage.BackgroundTransparency = 1; MiscPage.Visible = false; MiscPage.Name = "MiscPage"

local StatusLabel = Instance.new("TextLabel", MainFrame)
StatusLabel.Text = "IDLE"
StatusLabel.Size = UDim2.new(1, 0, 0, 20)
StatusLabel.Position = UDim2.new(0, 0, 1, -15)
StatusLabel.BackgroundTransparency = 1
StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
StatusLabel.Font = Enum.Font.Code
StatusLabel.TextSize = 10
StatusLabel.ZIndex = 20

-- == BLOCK PAGE CONTENTS ==
local B_Delay, c1 = createInput(BlockPage, "Delay (s):", "0.16", 30)
local B_Hold, c2 = createInput(BlockPage, "Hold (s):", "0.12", 70)
local B_Dist, c3 = createInput(BlockPage, "Distance:", "10", 110)
local B_Pred, c3b = createInput(BlockPage, "Prediction:", "0", 150)
local B_Chance, c4 = createInput(BlockPage, "Chance (0-1):", "1", 190)
local B_LookTime, c5 = createInput(BlockPage, "Look Time (s):", "0.5", 230)
local B_PreDelay, c6 = createInput(BlockPage, "Look Ahead (s):", "0.05", 270)
local B_CautionDist, c7 = createInput(BlockPage, "Cautious Dist:", "15", 310)
local B_CautionRate, c8 = createInput(BlockPage, "Cautious Rate:", "0.05", 350)

local B_Toggle = createToggle(BlockPage, "Block: ON", 400)
B_Toggle.BackgroundColor3 = Color3.fromRGB(50, 150, 80); B_Toggle:SetAttribute("BaseColor", Color3.fromRGB(50, 150, 80))
registerTooltip(B_Toggle, "Auto-Blocks M1 Attacks.")

local B_LookToggle = createToggle(BlockPage, "Look At: OFF", 440)
B_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(B_LookToggle, "Faces the enemy BEFORE blocking.")

local B_MoveToggle = createToggle(BlockPage, "Auto Pos: OFF", 470)
B_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(B_MoveToggle, "Instantly glides 3 studs in front of the attacker.")

local B_CautionToggle = createToggle(BlockPage, "Cautious: OFF", 500)
B_CautionToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(B_CautionToggle, "Randomly blocks/stares to look human.")

-- == DASH PAGE CONTENTS ==
local D_Delay = createInput(DashPage, "Delay (s):", "0.12", 30)
local D_Hold = createInput(DashPage, "Hold (s):", "0.1", 70)
local D_Dist = createInput(DashPage, "Distance:", "10", 110)
local D_Pred = createInput(DashPage, "Prediction:", "0", 150)
local D_Chance = createInput(DashPage, "Chance (0-1):", "1", 190)
local D_LookTime = createInput(DashPage, "Look Time (s):", "0.5", 230)
local D_PreDelay = createInput(DashPage, "Look Ahead (s):", "0.05", 270)
local D_PostDelay = createInput(DashPage, "Post-Anim (s):", "0.1", 310)

local D_Toggle = createToggle(DashPage, "Dash Block: ON", 360)
D_Toggle.BackgroundColor3 = Color3.fromRGB(50, 150, 80); D_Toggle:SetAttribute("BaseColor", Color3.fromRGB(50, 150, 80))
registerTooltip(D_Toggle, "Auto-Blocks Dash Attacks.")

local D_SmartToggle = createToggle(DashPage, "Smart Hold: OFF", 400)
D_SmartToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(D_SmartToggle, "Waits for 'End/Punch' anim to START, then waits Post-Anim to unblock.")

local D_LookToggle = createToggle(DashPage, "Look At: OFF", 430)
D_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(D_LookToggle, "Faces the enemy BEFORE blocking dash.")

local D_MoveToggle = createToggle(DashPage, "Auto Pos: OFF", 460)
D_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(D_MoveToggle, "Instantly glides 3 studs in front of dash attacker.")

-- == PUNCH PAGE CONTENTS ==
local P_Delay, p1 = createInput(PunchPage, "Delay (s):", "0.05", 30)
local P_Hold, p2 = createInput(PunchPage, "Hold (s):", "0.1", 70)
local P_Dist, p3 = createInput(PunchPage, "Atk Dist:", "5", 110)
local P_LookDist, p3b = createInput(PunchPage, "Look Dist:", "15", 150)
local P_Chance, p4 = createInput(PunchPage, "Chance (0-1):", "1", 190)
local P_LookTime, p5 = createInput(PunchPage, "Look Time (s):", "0.35", 230)
local P_ComboReset, p6 = createInput(PunchPage, "Cooldown (s):", "2", 270)

local P_Toggle = createToggle(PunchPage, "Punch: OFF", 320)
registerTooltip(P_Toggle, "Block ON: Counter-Attack mode.\nBlock OFF: Aggro mode.")

local P_LookToggle = createToggle(PunchPage, "Look At: OFF", 360)
P_LookToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(P_LookToggle, "Locks rotation onto the target while punching.")

local P_GlideToggle = createToggle(PunchPage, "Glide: OFF", 390)
P_GlideToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(P_GlideToggle, "Smoothly moves closer to the target while punching.")

local P_ComboToggle = createToggle(PunchPage, "Max 3 Hits: OFF", 420)
P_ComboToggle.Size = UDim2.new(0.9, 0, 0, 25)
registerTooltip(P_ComboToggle, "Stops punching after 3 consecutive M1s detected on yourself.")

-- == MISC PAGE CONTENTS ==
local M_DashSpeed, m1 = createInput(MiscPage, "Dash Speed:", "100", 30)
local M_DashDecay, m2 = createInput(MiscPage, "Dash Decay (s):", "0.3", 70)
local M_DashCD, m3 = createInput(MiscPage, "Dash CD (s):", "2", 110)
local M_CamSmooth, m4 = createInput(MiscPage, "Cam Smooth:", "0.1", 150)

local M_SideDashToggle = createToggle(MiscPage, "Side Dash: OFF", 200)
M_SideDashToggle.Size = UDim2.new(0.9, 0, 0, 30)
registerTooltip(M_SideDashToggle, "Aggro Mode: Dashes L/R around enemy.")

local M_CamLockToggle = createToggle(MiscPage, "Cam Lock: OFF", 240)
M_CamLockToggle.Size = UDim2.new(0.9, 0, 0, 30)
registerTooltip(M_CamLockToggle, "Guides camera to target.")

-- =================================================================================
-- 5. TRANSITION & HIDING LOGIC (Fixed)
-- =================================================================================

local currentTab = "Block" 
local transitionID = 0 -- Prevents async overlap glitches

local function getElements(page)
	local elements = {}
	for _, child in pairs(page:GetChildren()) do
		if child:IsA("GuiObject") then table.insert(elements, child) end
	end
	return elements
end

local function animateOut(page)
	local elements = getElements(page)
	for _, el in pairs(elements) do
		-- Store original pos
		if not el:GetAttribute("OrgPos") then
			el:SetAttribute("OrgPos", el.Position)
			el:SetAttribute("OrgSize", el.Size)
		end
		
		-- "Explode" effect
		local rotDir = math.random(0, 1) == 1 and 1 or -1
		local tweenGoals = { Rotation = 180 * rotDir, Size = UDim2.new(0,0,0,0), BackgroundTransparency = 1 }
		
		if el:IsA("TextLabel") or el:IsA("TextButton") or el:IsA("TextBox") then tweenGoals.TextTransparency = 1 end
		tween(el, {0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In}, tweenGoals)
		
		-- Fade children
		for _, sub in pairs(el:GetDescendants()) do
			if sub:IsA("TextLabel") or sub:IsA("TextBox") or sub:IsA("TextButton") then
				tween(sub, {0.3}, {TextTransparency = 1, BackgroundTransparency = 1})
			end
		end
	end
end

local function animateIn(page)
	page.Visible = true 
	local elements = getElements(page)
	for _, el in pairs(elements) do
		local orgPos = el:GetAttribute("OrgPos") or el.Position
		local orgSize = el:GetAttribute("OrgSize") or el.Size
		el:SetAttribute("OrgPos", orgPos)
		
		-- Set Start State
		el.Rotation = math.random(-90, 90)
		el.Size = UDim2.new(0, 0, 0, 0) 
		el.BackgroundTransparency = 1
		
		-- Prepare Tweens
		local endTransparency = (el:IsA("TextButton") or el:IsA("TextBox")) and 0 or 1
		local tweenGoals = { Rotation = 0, Size = orgSize, BackgroundTransparency = endTransparency }
		
		if el:IsA("TextButton") or el:IsA("TextLabel") or el:IsA("TextBox") then tweenGoals.TextTransparency = 0 end
		tween(el, {0.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out}, tweenGoals)
		
		-- Fade In children
		for _, sub in pairs(el:GetDescendants()) do
			if sub:IsA("TextLabel") or sub:IsA("TextBox") or sub:IsA("TextButton") then
				tween(sub, {0.3}, {TextTransparency = 0})
				if sub:IsA("TextBox") then tween(sub, {0.3}, {BackgroundTransparency = 0}) end
			end
		end
	end
end

local function switchTab(tabName, btn, indicatorPos, contentHeight)
	if currentTab == tabName then return end
	currentTab = tabName
	transitionID = transitionID + 1
	local currentID = transitionID
	
	-- Colors
	tween(BlockTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(DashTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(PunchTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(MiscTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(btn, {0.3}, {TextColor3 = Color3.new(1,1,1)})
	tween(TabIndicator, {0.3, Enum.EasingStyle.Back}, {Position = indicatorPos})
	
	-- Update Scrolling Canvas
	ScrollContainer.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
	
	-- Clean Up Old
	animateOut(BlockPage)
	animateOut(DashPage)
	animateOut(PunchPage)
	animateOut(MiscPage)
	
	-- Bring In New
	if tabName == "Block" then animateIn(BlockPage)
	elseif tabName == "Dash" then animateIn(DashPage)
	elseif tabName == "Punch" then animateIn(PunchPage)
	elseif tabName == "Misc" then animateIn(MiscPage)
	end
	
	-- Force Hide logic to prevent overlaps
	task.delay(0.4, function()
		if transitionID ~= currentID then return end -- If user switched again, don't touch
		BlockPage.Visible = (tabName == "Block")
		DashPage.Visible = (tabName == "Dash")
		PunchPage.Visible = (tabName == "Punch")
		MiscPage.Visible = (tabName == "Misc")
	end)
end

BlockTabBtn.MouseButton1Click:Connect(function() switchTab("Block", BlockTabBtn, UDim2.new(0, 2, 1, -3), TAB_HEIGHTS.Block) end)
DashTabBtn.MouseButton1Click:Connect(function() switchTab("Dash", DashTabBtn, UDim2.new(0.25, 2, 1, -3), TAB_HEIGHTS.Dash) end)
PunchTabBtn.MouseButton1Click:Connect(function() switchTab("Punch", PunchTabBtn, UDim2.new(0.5, 2, 1, -3), TAB_HEIGHTS.Punch) end)
MiscTabBtn.MouseButton1Click:Connect(function() switchTab("Misc", MiscTabBtn, UDim2.new(0.75, 2, 1, -3), TAB_HEIGHTS.Misc) end)

-- =================================================================================
-- 6. TOGGLE LOGIC
-- =================================================================================

local settings = {
	Block = {Enabled = true, Look = false, Move = false, Caution = false},
	Dash = {Enabled = true, Look = false, Move = false, Smart = false},
	Punch = {Enabled = false, Look = false, Glide = false, Max3 = false},
	Misc = {SideDash = false, CamLock = false}
}

local function updateToggleVisuals(btn, enabled, textOn, textOff)
	local newColor = enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
	btn.Text = enabled and textOn or textOff
	btn:SetAttribute("BaseColor", newColor) 
	tween(btn, {0.2}, {BackgroundColor3 = newColor})
end

-- Toggle Connections
B_Toggle.MouseButton1Click:Connect(function() settings.Block.Enabled = not settings.Block.Enabled; updateToggleVisuals(B_Toggle, settings.Block.Enabled, "Block: ON", "Block: OFF") end)
B_LookToggle.MouseButton1Click:Connect(function() settings.Block.Look = not settings.Block.Look; updateToggleVisuals(B_LookToggle, settings.Block.Look, "Look At: ON", "Look At: OFF") end)
B_MoveToggle.MouseButton1Click:Connect(function() settings.Block.Move = not settings.Block.Move; updateToggleVisuals(B_MoveToggle, settings.Block.Move, "Auto Pos: ON", "Auto Pos: OFF") end)
B_CautionToggle.MouseButton1Click:Connect(function() settings.Block.Caution = not settings.Block.Caution; updateToggleVisuals(B_CautionToggle, settings.Block.Caution, "Cautious: ON", "Cautious: OFF") end)

D_Toggle.MouseButton1Click:Connect(function() settings.Dash.Enabled = not settings.Dash.Enabled; updateToggleVisuals(D_Toggle, settings.Dash.Enabled, "Dash Block: ON", "Dash Block: OFF") end)
D_LookToggle.MouseButton1Click:Connect(function() settings.Dash.Look = not settings.Dash.Look; updateToggleVisuals(D_LookToggle, settings.Dash.Look, "Look At: ON", "Look At: OFF") end)
D_MoveToggle.MouseButton1Click:Connect(function() settings.Dash.Move = not settings.Dash.Move; updateToggleVisuals(D_MoveToggle, settings.Dash.Move, "Auto Pos: ON", "Auto Pos: OFF") end)
D_SmartToggle.MouseButton1Click:Connect(function() settings.Dash.Smart = not settings.Dash.Smart; updateToggleVisuals(D_SmartToggle, settings.Dash.Smart, "Smart Hold: ON", "Smart Hold: OFF") end)

P_Toggle.MouseButton1Click:Connect(function() settings.Punch.Enabled = not settings.Punch.Enabled; updateToggleVisuals(P_Toggle, settings.Punch.Enabled, "Punch: ON", "Punch: OFF") end)
P_LookToggle.MouseButton1Click:Connect(function() settings.Punch.Look = not settings.Punch.Look; updateToggleVisuals(P_LookToggle, settings.Punch.Look, "Look At: ON", "Look At: OFF") end)
P_GlideToggle.MouseButton1Click:Connect(function() settings.Punch.Glide = not settings.Punch.Glide; updateToggleVisuals(P_GlideToggle, settings.Punch.Glide, "Glide: ON", "Glide: OFF") end)
P_ComboToggle.MouseButton1Click:Connect(function() settings.Punch.Max3 = not settings.Punch.Max3; updateToggleVisuals(P_ComboToggle, settings.Punch.Max3, "Max 3 Hits: ON", "Max 3 Hits: OFF") end)

M_SideDashToggle.MouseButton1Click:Connect(function() settings.Misc.SideDash = not settings.Misc.SideDash; updateToggleVisuals(M_SideDashToggle, settings.Misc.SideDash, "Side Dash: ON", "Side Dash: OFF") end)
M_CamLockToggle.MouseButton1Click:Connect(function() settings.Misc.CamLock = not settings.Misc.CamLock; updateToggleVisuals(M_CamLockToggle, settings.Misc.CamLock, "Cam Lock: ON", "Cam Lock: OFF") end)

-- =================================================================================
-- 7. LOGIC
-- =================================================================================

local isBlocking = false
local isAttacking = false
local blockTask = nil 
local lookAtActive = false
local lookAtEndTime = 0
local currentlyDashing = false
local dashTarget = nil
local lastSideDashTime = 0

local function isRagdolled(char)
	if not char then return false end
	local comp = char:FindFirstChild("RagdollComponents")
	if not comp then return false end
	local total, active = 0, 0
	for _, child in pairs(comp:GetChildren()) do
		if child:IsA("BallSocketConstraint") then
			total = total + 1
			if child.Enabled then active = active + 1 end
		end
	end
	return total > 0 and (active / total) > 0.5
end

local function areWelded(myChar, targetChar)
	if not myChar or not targetChar then return false end
	local myRoot = myChar:FindFirstChild("HumanoidRootPart")
	if not myRoot then return false end
	for _, part in pairs(myRoot:GetConnectedParts(true)) do
		if part.Parent == targetChar or part.Parent.Parent == targetChar then return true end
	end
	local hum = myChar:FindFirstChild("Humanoid")
	if hum and (hum.Sit or hum:GetState() == Enum.HumanoidStateType.PlatformStanding) then return true end
	return false
end

local function getSafeLookCFrame(originPos, targetPos)
	local flatOrigin = Vector3.new(originPos.X, 0, originPos.Z)
	local flatTarget = Vector3.new(targetPos.X, 0, targetPos.Z)
	if (flatTarget - flatOrigin).Magnitude < 2 then return nil end 
	return CFrame.lookAt(flatOrigin, flatTarget)
end

local function addCharToCache(char)
	if not table.find(activeCharacters, char) then table.insert(activeCharacters, char) end
end
local function removeCharFromCache(char)
	local idx = table.find(activeCharacters, char)
	if idx then table.remove(activeCharacters, idx) end
end

local function getPredictedPos(char, predictionTime)
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return Vector3.zero end
	return root.Position + (root.Velocity * predictionTime)
end

local function isNearbyPredicted(char, maxDist, predictionTime)
	if not Player.Character then return false end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return false end
	local targetPos = getPredictedPos(char, predictionTime)
	return (myRoot.Position - targetPos).Magnitude <= maxDist
end

local function triggerSideDash(target)
	if isRagdolled(Player.Character) then return end
	local char = Player.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChild("Humanoid")
	local animator = hum and hum:FindFirstChild("Animator")
	
	if not root or not hum or not animator then return end
	if hum.WalkSpeed < 1 then return end 
	
	local cooldown = tonumber(M_DashCD.Text) or 2
	if os.clock() - lastSideDashTime < cooldown then return end
	lastSideDashTime = os.clock()
	
	currentlyDashing = true
	dashTarget = target
	local isRight = math.random() > 0.5
	local dirMultiplier = isRight and 1 or -1
	local track = animator:LoadAnimation(isRight and dashAnimRight or dashAnimLeft)
	track:Play()
	
	local speed = tonumber(M_DashSpeed.Text) or 100
	local duration = tonumber(M_DashDecay.Text) or 0.3
	local startTime = os.clock()
	
	local connection
	connection = RunService.Heartbeat:Connect(function()
		if hum.WalkSpeed < 1 then
			if connection then connection:Disconnect() end
			currentlyDashing = false
			dashTarget = nil
			return
		end
		local elapsed = os.clock() - startTime
		if elapsed >= duration or not root.Parent then
			if connection then connection:Disconnect() end
			currentlyDashing = false
			dashTarget = nil
			root.AssemblyLinearVelocity = Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
			return
		end
		local alpha = elapsed / duration
		local currentSpeed = speed * (1 - (alpha * 0.7)) 
		local rightDir = root.CFrame.RightVector
		local oldVel = root.AssemblyLinearVelocity
		root.AssemblyLinearVelocity = (rightDir * currentSpeed * dirMultiplier) + Vector3.new(0, oldVel.Y, 0)
	end)
end

local function triggerGlide(targetChar)
	if not settings.Punch.Glide or isRagdolled(Player.Character) then return end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
	if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
	
	local dist = (myRoot.Position - targetRoot.Position).Magnitude
	if dist > 3 and dist < 20 then
		local alpha = 0.3
		local newPos = myRoot.Position:Lerp(targetRoot.Position, alpha)
		local finalCF = getSafeLookCFrame(newPos, targetRoot.Position)
		if not finalCF then return end
		finalCF = finalCF + Vector3.new(0, myRoot.Position.Y, 0)
		TweenService:Create(myRoot, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = finalCF}):Play()
	end
end

local function triggerBlockGlide(targetChar)
	if not Player.Character then return end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
	if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
	
	local direction = (myRoot.Position - targetRoot.Position).Unit
	local targetPos = targetRoot.Position + (direction * 3)
	local finalPos = Vector3.new(targetPos.X, myRoot.Position.Y, targetPos.Z)
	local safeLook = getSafeLookCFrame(finalPos, targetRoot.Position)
	if safeLook then
		safeLook = safeLook + Vector3.new(0, myRoot.Position.Y, 0)
		TweenService:Create(myRoot, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = safeLook}):Play()
	end
end

local function activateLookAt(duration)
	if isRagdolled(Player.Character) then return end
	lookAtEndTime = os.clock() + duration
	lookAtActive = true
end

local function attemptPunch(targetChar)
	if isAttacking or isRagdolled(Player.Character) then return end
	if isRagdolled(targetChar) then return end 
	if settings.Punch.Max3 and comboCooldownActive then return end 
	
	local chance = tonumber(P_Chance.Text) or 1
	if math.random() > chance then return end
	
	local delay = tonumber(P_Delay.Text) or 0.05
	local hold = tonumber(P_Hold.Text) or 0.1
	isAttacking = true
	
	task.delay(delay, function()
		if isRagdolled(Player.Character) then isAttacking = false return end
		sendRemote("M1", true)
		if settings.Punch.Look then
			local lookDuration = tonumber(P_LookTime.Text) or 0.35
			activateLookAt(lookDuration)
		end
		if targetChar then triggerGlide(targetChar) end
		StatusLabel.Text = "ATTACKING"
		StatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		task.delay(hold, function()
			sendRemote("M1", false)
			StatusLabel.Text = "IDLE"
			StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
			isAttacking = false
		end)
	end)
end

local function triggerGenericBlock(targetChar, isDashBlock, trackObj)
	if isRagdolled(Player.Character) then return end
	
	local cfg = isDashBlock and {
		Delay = tonumber(D_Delay.Text), Hold = tonumber(D_Hold.Text),
		Look = settings.Dash.Look, Move = settings.Dash.Move,
		PreDelay = tonumber(D_PreDelay.Text), LookTime = tonumber(D_LookTime.Text),
		Smart = settings.Dash.Smart, PostDelay = tonumber(D_PostDelay.Text)
	} or {
		Delay = tonumber(B_Delay.Text), Hold = tonumber(B_Hold.Text),
		Look = settings.Block.Look, Move = settings.Block.Move,
		PreDelay = tonumber(B_PreDelay.Text), LookTime = tonumber(B_LookTime.Text),
		Smart = false 
	}
	
	task.delay(cfg.Delay or 0.16, function()
		if isRagdolled(Player.Character) then return end
		
		if cfg.Move then triggerBlockGlide(targetChar) end
		
		if not isBlocking then
			isBlocking = true
			sendRemote("Block", true)
			StatusLabel.Text = isDashBlock and "DASH BLOCK" or "BLOCKING"
			StatusLabel.TextColor3 = Color3.fromRGB(80, 255, 120)
		end
		
		if blockTask then task.cancel(blockTask) end
		
		-- Smart Hold Logic (Wait for Start)
		if cfg.Smart and isDashBlock then
			StatusLabel.Text = "WAITING END"
			local animator = targetChar:FindFirstChild("Animator", true)
			local endAnimTrack = nil
			if animator then
				-- Check existing
				for _, t in pairs(animator:GetPlayingAnimationTracks()) do
					local id = string.match(t.Animation.AnimationId, "%d+")
					if dashEnds[id] then endAnimTrack = t break end
				end
				-- Wait for new
				if not endAnimTrack then
					local connection
					connection = animator.AnimationPlayed:Connect(function(t)
						local id = string.match(t.Animation.AnimationId, "%d+")
						if dashEnds[id] then endAnimTrack = t connection:Disconnect() end
					end)
					local timeout = 0
					while not endAnimTrack and timeout < 1.5 do
						timeout = timeout + RunService.Heartbeat:Wait()
					end
					if connection then connection:Disconnect() end
				end
			end
			
			task.wait(cfg.PostDelay or 0.1)
			sendRemote("Block", false)
			isBlocking = false
			blockTask = nil
			StatusLabel.Text = "IDLE"
			StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
			
			if settings.Punch.Enabled then
				if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
					attemptPunch(targetChar) 
				end
			end
		else
			-- Standard Hold
			blockTask = task.delay(cfg.Hold or 0.12, function()
				sendRemote("Block", false)
				isBlocking = false
				blockTask = nil
				StatusLabel.Text = "IDLE"
				StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
				if settings.Punch.Enabled then
					if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then 
						attemptPunch(targetChar) 
					end
				end
			end)
		end
	end)
	
	if cfg.Look then
		local lookStartDelay = math.max(0, (cfg.Delay or 0.16) - (cfg.PreDelay or 0.05))
		task.delay(lookStartDelay, function()
			if areWelded(Player.Character, targetChar) then return end
			activateLookAt(cfg.LookTime or 0.5)
		end)
	end
end

local function hookAnimator(animator, char)
	animator.AnimationPlayed:Connect(function(track)
		if isRagdolled(Player.Character) then return end
		if not track.Animation then return end
		if char == Player.Character then return end
		
		local rawId = string.match(track.Animation.AnimationId, "%d+")
		
		if settings.Block.Enabled and m1Database[rawId] and not processedTracks[track] then
			local chance = tonumber(B_Chance.Text) or 1
			if math.random() > chance then return end
			local pred = tonumber(B_Pred.Text) or 0
			local reqDist = tonumber(B_Dist.Text) or 10
			if isNearbyPredicted(char, reqDist, pred) then
				processedTracks[track] = true
				track.Ended:Connect(function() processedTracks[track] = nil end)
				triggerGenericBlock(char, false, track)
			end
		end
		
		if settings.Dash.Enabled and dashStarts[rawId] and not processedTracks[track] then
			local chance = tonumber(D_Chance.Text) or 1
			if math.random() > chance then return end
			local pred = tonumber(D_Pred.Text) or 0
			local reqDist = tonumber(D_Dist.Text) or 10
			if isNearbyPredicted(char, reqDist, pred) then
				processedTracks[track] = true
				track.Ended:Connect(function() processedTracks[track] = nil end)
				triggerGenericBlock(char, true, track)
			end
		end
	end)
end

local function hookLocalCharacter(char)
	local hum = char:WaitForChild("Humanoid", 5)
	local animator = hum and hum:WaitForChild("Animator", 5)
	if not animator then return end
	
	animator.AnimationPlayed:Connect(function(track)
		if not track.Animation then return end
		local rawId = string.match(track.Animation.AnimationId, "%d+")
		
		if settings.Punch.Max3 and m1Database[rawId] then
			if os.clock() - lastLocalPunchTime > 1.5 then localComboCount = 0 end
			localComboCount = localComboCount + 1
			lastLocalPunchTime = os.clock()
			if localComboCount >= 3 then
				comboCooldownActive = true
				StatusLabel.Text = "COMBO COOLDOWN"
				StatusLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
				local cdTime = tonumber(P_ComboReset.Text) or 2
				task.delay(cdTime, function()
					comboCooldownActive = false
					localComboCount = 0
					StatusLabel.Text = "IDLE"
					StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
				end)
			end
		end
	end)
end

local function hookCharacter(char)
	if not char then return end
	addCharToCache(char)
	if char == Player.Character then hookLocalCharacter(char) return end
	local humanoid = char:FindFirstChild("Humanoid") or char:FindFirstChild("AnimationController")
	if not humanoid then humanoid = char:WaitForChild("Humanoid", 5) end
	if not humanoid then return end
	if humanoid:IsA("Humanoid") then humanoid.Died:Connect(function() removeCharFromCache(char) end) end
	char.AncestryChanged:Connect(function(_, parent) if not parent then removeCharFromCache(char) end end)
	local animator = humanoid:FindFirstChild("Animator")
	if not animator then animator = humanoid:WaitForChild("Animator", 5) end
	if not animator then return end
	hookAnimator(animator, char)
end

-- =================================================================================
-- 8. RUNTIME LOOPS
-- =================================================================================

RunService.Heartbeat:Connect(function()
	if isRagdolled(Player.Character) then return end
	if not Player.Character then return end
	
	for _, char in pairs(activeCharacters) do
		if char ~= Player.Character and char.Parent then
			local animator = char:FindFirstChild("Animator", true)
			if animator then
				for _, track in pairs(animator:GetPlayingAnimationTracks()) do
					local id = string.match(track.Animation.AnimationId, "%d+")
					if not processedTracks[track] then
						if settings.Block.Enabled and m1Database[id] then
							local pred = tonumber(B_Pred.Text) or 0
							local reqDist = tonumber(B_Dist.Text) or 10
							if isNearbyPredicted(char, reqDist, pred) then
								processedTracks[track] = true
								track.Ended:Connect(function() processedTracks[track] = nil end)
								triggerGenericBlock(char, false, track)
							end
						elseif settings.Dash.Enabled and dashStarts[id] then
							local pred = tonumber(D_Pred.Text) or 0
							local reqDist = tonumber(D_Dist.Text) or 10
							if isNearbyPredicted(char, reqDist, pred) then
								processedTracks[track] = true
								track.Ended:Connect(function() processedTracks[track] = nil end)
								triggerGenericBlock(char, true, track)
							end
						end
					end
				end
			end
		end
	end
end)

task.spawn(function()
	while task.wait(1) do
		if not settings.Block.Caution or isRagdolled(Player.Character) or isBlocking then continue end
		local rate = tonumber(B_CautionRate.Text) or 0.05
		if math.random() > rate then continue end
		local dist = tonumber(B_CautionDist.Text) or 15
		local target = nil
		for _, char in pairs(activeCharacters) do
			if isNearbyPredicted(char, dist, 0) then target = char break end
		end
		if target then
			activateLookAt(0.5)
			sendRemote("Block", true)
			task.wait(0.2)
			sendRemote("Block", false)
		end
	end
end)

RunService.Heartbeat:Connect(function()
	if settings.Block.Enabled then return end 
	if not settings.Punch.Enabled or isRagdolled(Player.Character) then return end
	
	if not Player.Character then return end
	local atkDist = tonumber(P_Dist.Text) or 5
	local lookDist = tonumber(P_LookDist.Text) or 15
	
	local foundTarget = nil
	if currentlyDashing and dashTarget and dashTarget.Parent and isNearbyPredicted(dashTarget, lookDist, 0) then
		foundTarget = dashTarget
	else
		for _, char in pairs(activeCharacters) do
			if char ~= Player.Character and char.Parent then
				if isNearbyPredicted(char, lookDist, 0) then foundTarget = char break end
			end
		end
	end
	
	if foundTarget then
		if isNearbyPredicted(foundTarget, atkDist, 0) then
			attemptPunch(foundTarget)
			if settings.Misc.SideDash then triggerSideDash(foundTarget) end
		elseif settings.Punch.Look then
			activateLookAt(0.1) 
		end
	end
end)

RunService.RenderStepped:Connect(function()
	if settings.Misc.CamLock then
		local camTarget = nil
		if currentlyDashing and dashTarget and dashTarget.Parent then camTarget = dashTarget
		else
			local closestDist = 100
			for _, char in pairs(activeCharacters) do
				if char ~= Player.Character and char.Parent then
					local targetRoot = char:FindFirstChild("HumanoidRootPart")
					if targetRoot and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
						local dist = (Player.Character.HumanoidRootPart.Position - targetRoot.Position).Magnitude
						if dist < closestDist then closestDist = dist camTarget = char end
					end
				end
			end
		end
		if camTarget and camTarget:FindFirstChild("HumanoidRootPart") then
			local cam = Workspace.CurrentCamera
			local smooth = tonumber(M_CamSmooth.Text) or 0.1
			local targetPos = camTarget.HumanoidRootPart.Position
			local goalCF = CFrame.lookAt(cam.CFrame.Position, targetPos)
			cam.CFrame = cam.CFrame:Lerp(goalCF, smooth)
		end
	end

	if (not lookAtActive and not currentlyDashing) or isRagdolled(Player.Character) then return end
	if not currentlyDashing and os.clock() > lookAtEndTime then lookAtActive = false return end
	
	if not Player.Character then return end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return end
	
	local targetChar = nil
	if currentlyDashing and dashTarget and dashTarget.Parent then targetChar = dashTarget
	else
		local closestDist = 50 
		for _, char in pairs(activeCharacters) do
			if char ~= Player.Character and char.Parent then
				if areWelded(Player.Character, char) then continue end 
				local targetRoot = char:FindFirstChild("HumanoidRootPart")
				if targetRoot then
					local dist = (myRoot.Position - targetRoot.Position).Magnitude
					if dist < closestDist then closestDist = dist targetChar = char end
				end
			end
		end
	end
	
	if targetChar then
		local targetPos = targetChar.HumanoidRootPart.Position
		local safeCF = getSafeLookCFrame(myRoot.Position, targetPos)
		if safeCF then
			local goalCF = safeCF + Vector3.new(0, myRoot.Position.Y, 0)
			if currentlyDashing then myRoot.CFrame = goalCF
			else myRoot.CFrame = myRoot.CFrame:Lerp(goalCF, 0.3) end
		end
	end
end)

if Player.Character then hookCharacter(Player.Character) end
Player.CharacterAdded:Connect(hookCharacter)

for _, desc in pairs(Workspace:GetDescendants()) do
	if desc:IsA("Model") and desc:FindFirstChild("Humanoid") then task.spawn(function() hookCharacter(desc) end) end
end
Workspace.DescendantAdded:Connect(function(desc)
	if desc:IsA("Model") and desc:FindFirstChild("Humanoid") then hookCharacter(desc) end
end)
