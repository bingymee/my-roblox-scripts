-- ROBLOX LOCAL SCRIPT
-- FINAL: Mobile Optimized (Minimize Button), Smart Nail Filter
-- Features: Auto-Block (M1/Dash/Move/Nail), Auto-Punch, Dash, Cam Lock, Cache, Blatant

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local Player = Players.LocalPlayer

-- =================================================================================
-- 1. CONFIG & DATABASE
-- =================================================================================

-- [Standard M1 Attacks]
local m1Database = {
	["127314304761047"] = true, ["77891317857963"] = true, ["84446039611604"] = true, ["114159183912233"] = true,
	["101101710876334"] = true, ["124127341057164"] = true, ["100901440555342"] = true, ["85853405255331"] = true,
	["85692420698843"] = true, ["75662531587920"] = true, ["130769245088771"] = true, ["103631040324206"] = true,
	["107867399798954"] = true, ["134486729011918"] = true, ["77034551070437"] = true, ["83150158223563"] = true,
	["136031609325321"] = true, ["120212532321192"] = true, ["74960987180381"] = true, ["122575871777232"] = true,
	["81483118494377"] = true, ["123762736246826"] = true, ["78443495730840"] = true, ["92893455375455"] = true,
	["130573375727993"] = true, ["114333120271557"] = true, ["131141291261313"] = true, ["70618047941591"] = true,
	["110804273799167"] = true, ["124509785398074"] = true, ["88637553004334"] = true, ["113533567296840"] = true,
	["131893897709436"] = true, ["134129845570461"] = true, ["97929415765630"] = true, ["124430020094189"] = true,
	["102875041440001"] = true, ["134933697595606"] = true, ["91251938763353"] = true, ["133137041054089"] = true,
	["122459875105285"] = true, ["135793390993834"] = true, ["93221245142809"] = true, ["73110247017887"] = true,
	["113978422458492"] = true, ["74467323861948"] = true, ["112264192271783"] = true, ["91014732452187"] = true,
}

local m1Exceptions = {
	["124430020094189"] = -0.05,
}

local dashStarts = {
	["78290593213759"] = true, ["81171550723416"] = true, ["16900584124"] = true, ["107027465005454"] = true,
	["104708203440312"] = true, ["83008536875803"] = true, ["102141442579104"] = true, ["134054487113051"] = true,
	["113533567296840"] = true,
}

local dashEnds = {
	["82190646305055"] = true, ["136991308458459"] = true, ["16897565629"] = true, ["72484334716316"] = true,
	["77242304295828"] = true, ["89684566192164"] = true, ["99230829853381"] = true, ["74672338436170"] = true,
}

-- [Special Moves]
local specialMovesDatabase = {
	["18963762189"] = {D=0.25, H=0.1}, ["78096097412529"] = {D=0.3, H=0.2}, ["18879921457"] = {D=0.5, H=0.3},
	["17328223121"] = {D=0.3, H=0.1}, ["17363525337"] = {D=0.5, H=0.2}, ["118843633382039"] = {D=0.4, H=0.2},
	["86329508817928"] = {D=0.4, H=0.2}, ["95445150598735"] = {D=0.2, H=2}, ["108015670641340"] = {D=0.6, H=0.3},
	["119892721851554"] = {D=0.4, H=1}, ["137836568814360"] = {D=0.5, H=2.5}, ["96591754150859"] = {D=0.5, H=2.5},
	["128608804630313"] = {D=0.4, H=0.5}, ["85046933809524"] = {D=0, H=4}, ["18885421107"] = {D=0, H=0.3},
	["99481834813123"] = {D=0.2, H=2.5}, ["82062508250907"] = {D=0, H=0.2}, ["106085904233993"] = {D=0.1, H=0.3},
	["78027079909373"] = {D=0, H=5}, ["126428004652057"] = {D=0.1, H=3}, ["132072760933363"] = {D=0.1, H=0.3},
	["137425788736528"] = {D=0.2, H=2.5}, ["91327391278757"] = {D=0.05, H=0.3},
	["75992973286097"] = {D=0.3, H=1}, ["137904609365921"] = {D=0, H=0.7}, ["130395218019480"] = {D=0, H=1.2},
}

-- [Counter/I-Frame Animations]
local counterAnims = {
	["107905388923142"] = true, ["128786694565206"] = true, ["124404196830025"] = true,
}

local activeCharacters = {} 
local activeNails = {}
local processedTracks = {}

local localComboCount = 0
local lastLocalPunchTime = 0
local comboCooldownActive = false

local dashAnimRight = Instance.new("Animation"); dashAnimRight.AnimationId = "rbxassetid://16482641019"
local dashAnimLeft = Instance.new("Animation"); dashAnimLeft.AnimationId = "rbxassetid://16482659401"

-- UI SIZING
local isMobile = UserInputService.TouchEnabled and not UserInputService.MouseEnabled
local SCALE = isMobile and 0.6 or 1
local TAB_HEIGHTS = {
	Block = 550 * SCALE, Dash = 550 * SCALE, Moves = 320 * SCALE, Punch = 550 * SCALE, Misc = 500 * SCALE
}

-- =================================================================================
-- 2. REMOTE HANDLING
-- =================================================================================

local Remote = nil
task.spawn(function()
	local success, result = pcall(function()
		return Player:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("AttackInput")
	end)
	if success then Remote = result end
end)

local function sendRemote(action, state)
	if not Remote then return end
	Remote:FireServer(action, state)
end

-- =================================================================================
-- 3. UI CONSTRUCTION
-- =================================================================================

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "ModernCombatUI"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = Player:WaitForChild("PlayerGui")

-- Tooltip
local TooltipFrame = Instance.new("Frame")
TooltipFrame.Name = "Tooltip"
TooltipFrame.Size = UDim2.new(0, 200 * SCALE, 0, 0)
TooltipFrame.AutomaticSize = Enum.AutomaticSize.Y
TooltipFrame.BackgroundColor3 = Color3.fromRGB(15, 15, 20)
TooltipFrame.BorderSizePixel = 0
TooltipFrame.Visible = false
TooltipFrame.ZIndex = 200 
TooltipFrame.Parent = ScreenGui

local TTStroke = Instance.new("UIStroke", TooltipFrame); TTStroke.Color = Color3.fromRGB(60, 60, 70); TTStroke.Thickness = 1
local TTCorner = Instance.new("UICorner", TooltipFrame); TTCorner.CornerRadius = UDim.new(0, 6)
local TTLabel = Instance.new("TextLabel", TooltipFrame)
TTLabel.Size = UDim2.new(1, -10, 0, 0); TTLabel.Position = UDim2.new(0, 5, 0, 5); TTLabel.AutomaticSize = Enum.AutomaticSize.Y
TTLabel.BackgroundTransparency = 1; TTLabel.TextColor3 = Color3.new(0.9, 0.9, 0.9); TTLabel.Font = Enum.Font.Gotham
TTLabel.TextSize = 11 * SCALE; TTLabel.TextWrapped = true; TTLabel.TextXAlignment = Enum.TextXAlignment.Left; TTLabel.ZIndex = 201; TTLabel.Parent = TooltipFrame
local TTPadding = Instance.new("UIPadding", TooltipFrame); TTPadding.PaddingBottom = UDim.new(0, 5)

-- Minimize Button (Mobile Friendly)
local MinBtn = Instance.new("TextButton")
MinBtn.Name = "Minimize"
MinBtn.Size = UDim2.new(0, 40 * SCALE, 0, 40 * SCALE)
MinBtn.Position = UDim2.new(0.02, 0, 0.05, 0) -- Top left safe zone
MinBtn.BackgroundColor3 = Color3.fromRGB(35, 35, 40)
MinBtn.Text = "UI"
MinBtn.TextColor3 = Color3.new(1,1,1)
MinBtn.Font = Enum.Font.GothamBold
MinBtn.TextSize = 12 * SCALE
MinBtn.Parent = ScreenGui
local MinCorner = Instance.new("UICorner", MinBtn); MinCorner.CornerRadius = UDim.new(0, 8)

-- Main Window
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 280 * SCALE, 0, 450 * SCALE)
-- Center on mobile to ensure visibility, offset on PC
MainFrame.Position = isMobile and UDim2.new(0.5, 0, 0.5, 0) or UDim2.new(0.1, 0, 0.2, 0)
MainFrame.AnchorPoint = isMobile and Vector2.new(0.5, 0.5) or Vector2.new(0, 0)
MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 30)
MainFrame.BorderSizePixel = 0
MainFrame.Active = true
MainFrame.ClipsDescendants = true
MainFrame.Parent = ScreenGui

MinBtn.MouseButton1Click:Connect(function()
	MainFrame.Visible = not MainFrame.Visible
end)

local MainCorner = Instance.new("UICorner", MainFrame); MainCorner.CornerRadius = UDim.new(0, 10 * SCALE)
local MainStroke = Instance.new("UIStroke", MainFrame); MainStroke.Color = Color3.fromRGB(50, 50, 60); MainStroke.Thickness = 2

-- Drag Logic (Touch + Mouse)
local dragging, dragInput, dragStart, startPos
MainFrame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = MainFrame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)

MainFrame.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and dragging then
		local delta = input.Position - dragStart
		MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

local function tween(obj, info, props) TweenService:Create(obj, TweenInfo.new(unpack(info)), props):Play() end

local function registerTooltip(button, text)
	button.MouseEnter:Connect(function()
		TTLabel.Text = text; TooltipFrame.Visible = true; TooltipFrame.BackgroundTransparency = 1; TTLabel.TextTransparency = 1
		tween(TooltipFrame, {0.2}, {BackgroundTransparency = 0.1}); tween(TTLabel, {0.2}, {TextTransparency = 0})
	end)
	button.MouseMoved:Connect(function()
		local m = UserInputService:GetMouseLocation(); TooltipFrame.Position = UDim2.fromOffset(m.X + 15, m.Y + 15)
	end)
	button.MouseLeave:Connect(function() TooltipFrame.Visible = false end)
end

local function createInput(parent, text, default, yPos)
	local Container = Instance.new("Frame", parent)
	Container.Size = UDim2.new(0.9, 0, 0, 30 * SCALE); Container.Position = UDim2.new(0.5, 0, 0, yPos * SCALE); Container.AnchorPoint = Vector2.new(0.5, 0.5)
	Container.BackgroundTransparency = 1; Container.ZIndex = 2; Container:SetAttribute("OrgSize", Container.Size)

	local Label = Instance.new("TextLabel", Container)
	Label.Text = text; Label.Size = UDim2.new(0.5, 0, 1, 0); Label.BackgroundTransparency = 1
	Label.TextColor3 = Color3.fromRGB(200, 200, 200); Label.TextXAlignment = Enum.TextXAlignment.Left; Label.Font = Enum.Font.GothamMedium
	Label.TextSize = 12 * SCALE; Label.ZIndex = 2

	local Box = Instance.new("TextBox", Container)
	Box.Text = default; Box.Size = UDim2.new(0.45, 0, 1, 0); Box.Position = UDim2.new(0.55, 0, 0, 0)
	Box.BackgroundColor3 = Color3.fromRGB(40, 40, 45); Box.TextColor3 = Color3.fromRGB(100, 255, 120); Box.Font = Enum.Font.Code
	Box.TextSize = 12 * SCALE; Box.ZIndex = 2; local Corner = Instance.new("UICorner", Box); Corner.CornerRadius = UDim.new(0, 6)
	
	Box.Focused:Connect(function() tween(Box, {0.2}, {BackgroundColor3 = Color3.fromRGB(50, 50, 60)}) end)
	Box.FocusLost:Connect(function() tween(Box, {0.2}, {BackgroundColor3 = Color3.fromRGB(40, 40, 45)}) end)
	return Box, Container
end

local function createToggle(parent, text, yPos)
	local Btn = Instance.new("TextButton", parent)
	Btn.Text = text; Btn.Size = UDim2.new(0.9, 0, 0, 35 * SCALE); Btn.Position = UDim2.new(0.5, 0, 0, yPos * SCALE); Btn.AnchorPoint = Vector2.new(0.5, 0.5)
	Btn.BackgroundColor3 = Color3.fromRGB(180, 60, 60); Btn.TextColor3 = Color3.new(1, 1, 1); Btn.Font = Enum.Font.GothamBold
	Btn.TextSize = 14 * SCALE; Btn.ZIndex = 2; Btn:SetAttribute("OrgSize", Btn.Size); Btn:SetAttribute("BaseColor", Btn.BackgroundColor3) 
	local Corner = Instance.new("UICorner", Btn); Corner.CornerRadius = UDim.new(0, 6)
	
	Btn.MouseEnter:Connect(function()
		local curr = Btn.BackgroundColor3
		tween(Btn, {0.2, Enum.EasingStyle.Quad}, {BackgroundColor3 = Color3.new(math.min(curr.R+0.1,1), math.min(curr.G+0.1,1), math.min(curr.B+0.1,1))})
	end)
	Btn.MouseLeave:Connect(function() tween(Btn, {0.2, Enum.EasingStyle.Quad}, {BackgroundColor3 = Btn:GetAttribute("BaseColor")}) end)
	return Btn
end

-- =================================================================================
-- 4. PAGE CONTENT & SCROLLING
-- =================================================================================

local TabFrame = Instance.new("Frame", MainFrame)
TabFrame.Size = UDim2.new(1, -10, 0, 40 * SCALE); TabFrame.Position = UDim2.new(0.5, 0, 0, 5); TabFrame.AnchorPoint = Vector2.new(0.5, 0)
TabFrame.BackgroundColor3 = Color3.fromRGB(35, 35, 40); TabFrame.ZIndex = 10
local TabCorner = Instance.new("UICorner", TabFrame); TabCorner.CornerRadius = UDim.new(0, 8)

-- TABS: 1/5 Width Each
local function createTabBtn(text, xOrder)
	local btn = Instance.new("TextButton", TabFrame)
	btn.Size = UDim2.new(0.2, 0, 1, 0); btn.Position = UDim2.new(0.2 * (xOrder-1), 0, 0, 0)
	btn.Text = text; btn.BackgroundTransparency = 1; btn.TextColor3 = Color3.fromRGB(150,150,150); btn.Font = Enum.Font.GothamBold
	btn.TextSize = 10 * SCALE; btn.ZIndex = 11; return btn
end

local BlockTabBtn = createTabBtn("BLOCK", 1); BlockTabBtn.TextColor3 = Color3.new(1,1,1)
local DashTabBtn = createTabBtn("DASH", 2)
local MovesTabBtn = createTabBtn("MOVES", 3)
local PunchTabBtn = createTabBtn("PUNCH", 4)
local MiscTabBtn = createTabBtn("MISC", 5)

local TabIndicator = Instance.new("Frame", TabFrame)
TabIndicator.Size = UDim2.new(0.2, -4, 0, 3); TabIndicator.Position = UDim2.new(0, 2, 1, -3)
TabIndicator.BackgroundColor3 = Color3.fromRGB(80, 200, 120); TabIndicator.BorderSizePixel = 0; TabIndicator.ZIndex = 12
local IndCorner = Instance.new("UICorner", TabIndicator); IndCorner.CornerRadius = UDim.new(1, 0)

local ScrollContainer = Instance.new("ScrollingFrame", MainFrame)
ScrollContainer.Size = UDim2.new(1, 0, 1, -50 * SCALE); ScrollContainer.Position = UDim2.new(0, 0, 0, 50 * SCALE); ScrollContainer.BackgroundTransparency = 1
ScrollContainer.BorderSizePixel = 0; ScrollContainer.ScrollBarThickness = 4; ScrollContainer.ScrollBarImageColor3 = Color3.fromRGB(80, 200, 120)
ScrollContainer.ClipsDescendants = true; ScrollContainer.CanvasSize = UDim2.new(0, 0, 0, 550 * SCALE)

local BlockPage = Instance.new("Frame", ScrollContainer); BlockPage.Size = UDim2.new(1, 0, 1, 0); BlockPage.BackgroundTransparency = 1; BlockPage.Visible = true; BlockPage.Name = "BlockPage"
local DashPage = Instance.new("Frame", ScrollContainer); DashPage.Size = UDim2.new(1, 0, 1, 0); DashPage.BackgroundTransparency = 1; DashPage.Visible = false; DashPage.Name = "DashPage"
local MovesPage = Instance.new("Frame", ScrollContainer); MovesPage.Size = UDim2.new(1, 0, 1, 0); MovesPage.BackgroundTransparency = 1; MovesPage.Visible = false; MovesPage.Name = "MovesPage"
local PunchPage = Instance.new("Frame", ScrollContainer); PunchPage.Size = UDim2.new(1, 0, 1, 0); PunchPage.BackgroundTransparency = 1; PunchPage.Visible = false; PunchPage.Name = "PunchPage"
local MiscPage = Instance.new("Frame", ScrollContainer); MiscPage.Size = UDim2.new(1, 0, 1, 0); MiscPage.BackgroundTransparency = 1; MiscPage.Visible = false; MiscPage.Name = "MiscPage"

local StatusLabel = Instance.new("TextLabel", MainFrame)
StatusLabel.Text = "IDLE"; StatusLabel.Size = UDim2.new(1, 0, 0, 20); StatusLabel.Position = UDim2.new(0, 0, 1, -15)
StatusLabel.BackgroundTransparency = 1; StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100); StatusLabel.Font = Enum.Font.Code; StatusLabel.TextSize = 10 * SCALE; StatusLabel.ZIndex = 20

-- == BLOCK PAGE CONTENTS ==
local B_Delay, c1 = createInput(BlockPage, "Delay (s):", "0.16", 30)
local B_Hold, c2 = createInput(BlockPage, "Hold (s):", "0.12", 70)
local B_Dist, c3 = createInput(BlockPage, "Distance:", "10", 110)
local B_Pred, c3b = createInput(BlockPage, "Prediction:", "0", 150)
local B_Chance, c4 = createInput(BlockPage, "Chance (0-1):", "1", 190)
local B_LookTime, c5 = createInput(BlockPage, "Look Time (s):", "0.5", 230)
local B_PreDelay, c6 = createInput(BlockPage, "Look Ahead (s):", "0.05", 270)
local B_CautionDist, c7 = createInput(BlockPage, "Cautious Dist:", "15", 310)
local B_CautionRate, c8 = createInput(BlockPage, "Cautious Rate:", "0.05", 350)

local B_Toggle = createToggle(BlockPage, "Block: ON", 400)
B_Toggle.BackgroundColor3 = Color3.fromRGB(50, 150, 80); B_Toggle:SetAttribute("BaseColor", Color3.fromRGB(50, 150, 80))
registerTooltip(B_Toggle, "Auto-Blocks M1 Attacks.")

local B_LookToggle = createToggle(BlockPage, "Look At: OFF", 440)
B_LookToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(B_LookToggle, "Faces the enemy BEFORE blocking.")

local B_MoveToggle = createToggle(BlockPage, "Auto Pos: OFF", 470)
B_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(B_MoveToggle, "Instantly glides 3 studs in front of the attacker.")

local B_CautionToggle = createToggle(BlockPage, "Cautious: OFF", 500)
B_CautionToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(B_CautionToggle, "Randomly blocks/stares to look human.")

-- == DASH PAGE CONTENTS ==
local D_Delay = createInput(DashPage, "Delay (s):", "0.12", 30)
local D_Hold = createInput(DashPage, "Hold (s):", "0.1", 70)
local D_Dist = createInput(DashPage, "Distance:", "10", 110)
local D_Pred = createInput(DashPage, "Prediction:", "0", 150)
local D_Chance = createInput(DashPage, "Chance (0-1):", "1", 190)
local D_LookTime = createInput(DashPage, "Look Time (s):", "0.5", 230)
local D_PreDelay = createInput(DashPage, "Look Ahead (s):", "0.05", 270)
local D_PostDelay = createInput(DashPage, "Post-Anim (s):", "0.1", 310)

local D_Toggle = createToggle(DashPage, "Dash Block: ON", 360)
D_Toggle.BackgroundColor3 = Color3.fromRGB(50, 150, 80); D_Toggle:SetAttribute("BaseColor", Color3.fromRGB(50, 150, 80))
registerTooltip(D_Toggle, "Auto-Blocks Dash Attacks.")

local D_SmartToggle = createToggle(DashPage, "Smart Hold: OFF", 400)
D_SmartToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(D_SmartToggle, "Waits for 'End/Punch' anim to START, then waits Post-Anim to unblock.")

local D_LookToggle = createToggle(DashPage, "Look At: OFF", 430)
D_LookToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(D_LookToggle, "Faces the enemy BEFORE blocking dash.")

local D_MoveToggle = createToggle(DashPage, "Auto Pos: OFF", 460)
D_MoveToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(D_MoveToggle, "Instantly glides 3 studs in front of dash attacker.")

-- == MOVES PAGE CONTENTS ==
local SP_Dist = createInput(MovesPage, "Distance:", "15", 30)
local SP_ExDelay = createInput(MovesPage, "Extra Delay:", "0", 70)
local SP_ExHold = createInput(MovesPage, "Extra Hold:", "0", 110)
local N_Dist = createInput(MovesPage, "Nail Dist:", "40", 150)

local SP_Toggle = createToggle(MovesPage, "Move Block: ON", 200)
SP_Toggle.BackgroundColor3 = Color3.fromRGB(50, 150, 80); SP_Toggle:SetAttribute("BaseColor", Color3.fromRGB(50, 150, 80))
registerTooltip(SP_Toggle, "Blocks specific Special Moves using fixed, optimal timings.")

local N_Toggle = createToggle(MovesPage, "Nail Block: OFF", 240)
N_Toggle.Size = UDim2.new(0.9, 0, 0, 30 * SCALE)
registerTooltip(N_Toggle, "Holds block if a 'Nail' object appears within range (Needle user counter).")

-- == PUNCH PAGE CONTENTS ==
local P_Delay, p1 = createInput(PunchPage, "Delay (s):", "0.05", 30)
local P_Hold, p2 = createInput(PunchPage, "Hold (s):", "0.1", 70)
local P_Dist, p3 = createInput(PunchPage, "Atk Dist:", "5", 110)
local P_LookDist, p3b = createInput(PunchPage, "Look Dist:", "15", 150)
local P_Chance, p4 = createInput(PunchPage, "Chance (0-1):", "1", 190)
local P_LookTime, p5 = createInput(PunchPage, "Look Time (s):", "0.35", 230)
local P_ComboReset, p6 = createInput(PunchPage, "Cooldown (s):", "2", 270)

local P_Toggle = createToggle(PunchPage, "Punch: OFF", 320)
registerTooltip(P_Toggle, "Block ON: Counter-Attack mode.\nBlock OFF: Aggro mode.")

local P_LookToggle = createToggle(PunchPage, "Look At: OFF", 360)
P_LookToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(P_LookToggle, "Locks rotation onto the target while punching.")

local P_GlideToggle = createToggle(PunchPage, "Glide: OFF", 390)
P_GlideToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(P_GlideToggle, "Smoothly moves closer to the target while punching.")

local P_ComboToggle = createToggle(PunchPage, "Max 3 Hits: OFF", 420)
P_ComboToggle.Size = UDim2.new(0.9, 0, 0, 25 * SCALE)
registerTooltip(P_ComboToggle, "Stops punching after 3 consecutive M1s detected on yourself.")

-- == MISC PAGE CONTENTS ==
local M_DashSpeed, m1 = createInput(MiscPage, "Dash Speed:", "100", 30)
local M_DashDecay, m2 = createInput(MiscPage, "Dash Decay (s):", "0.3", 70)
local M_DashCD, m3 = createInput(MiscPage, "Dash CD (s):", "2", 110)
local M_CamSmooth, m4 = createInput(MiscPage, "Cam Smooth:", "0.1", 150)

local M_SideDashToggle = createToggle(MiscPage, "Side Dash: OFF", 200)
M_SideDashToggle.Size = UDim2.new(0.9, 0, 0, 30 * SCALE)
registerTooltip(M_SideDashToggle, "Aggro Mode: Dashes L/R around enemy.")

local M_CamLockToggle = createToggle(MiscPage, "Cam Lock: OFF", 240)
M_CamLockToggle.Size = UDim2.new(0.9, 0, 0, 30 * SCALE)
registerTooltip(M_CamLockToggle, "Guides camera to target (Horizontal Only).")

local M_BlatantToggle = createToggle(MiscPage, "Blatant: OFF", 280)
M_BlatantToggle.Size = UDim2.new(0.9, 0, 0, 30 * SCALE)
registerTooltip(M_BlatantToggle, "Removes smoothing. Instantly teleports for Glide/Pos/Look.")

-- =================================================================================
-- 5. TRANSITION & HIDING LOGIC
-- =================================================================================

local currentTab = "Block" 
local transitionID = 0

local function getElements(page)
	local elements = {}
	for _, child in pairs(page:GetChildren()) do
		if child:IsA("GuiObject") then table.insert(elements, child) end
	end
	return elements
end

local function animateOut(page)
	local elements = getElements(page)
	for _, el in pairs(elements) do
		if not el:GetAttribute("OrgPos") then
			el:SetAttribute("OrgPos", el.Position); el:SetAttribute("OrgSize", el.Size)
		end
		local rotDir = math.random(0, 1) == 1 and 1 or -1
		local tweenGoals = { Rotation = 180 * rotDir, Size = UDim2.new(0,0,0,0), BackgroundTransparency = 1 }
		if el:IsA("TextLabel") or el:IsA("TextButton") or el:IsA("TextBox") then tweenGoals.TextTransparency = 1 end
		tween(el, {0.4, Enum.EasingStyle.Back, Enum.EasingDirection.In}, tweenGoals)
		for _, sub in pairs(el:GetDescendants()) do
			if sub:IsA("TextLabel") or sub:IsA("TextBox") or sub:IsA("TextButton") then tween(sub, {0.3}, {TextTransparency = 1, BackgroundTransparency = 1}) end
		end
	end
end

local function animateIn(page)
	page.Visible = true 
	local elements = getElements(page)
	for _, el in pairs(elements) do
		local orgPos = el:GetAttribute("OrgPos") or el.Position
		local orgSize = el:GetAttribute("OrgSize") or el.Size
		el:SetAttribute("OrgPos", orgPos)
		el.Rotation = math.random(-90, 90); el.Size = UDim2.new(0, 0, 0, 0); el.BackgroundTransparency = 1
		local endTransparency = (el:IsA("TextButton") or el:IsA("TextBox")) and 0 or 1
		local tweenGoals = { Rotation = 0, Size = orgSize, BackgroundTransparency = endTransparency }
		if el:IsA("TextButton") or el:IsA("TextLabel") or el:IsA("TextBox") then tweenGoals.TextTransparency = 0 end
		tween(el, {0.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out}, tweenGoals)
		for _, sub in pairs(el:GetDescendants()) do
			if sub:IsA("TextLabel") or sub:IsA("TextBox") or sub:IsA("TextButton") then tween(sub, {0.3}, {TextTransparency = 0})
				if sub:IsA("TextBox") then tween(sub, {0.3}, {BackgroundTransparency = 0}) end
			end
		end
	end
end

local function switchTab(tabName, btn, indicatorPos, contentHeight)
	if currentTab == tabName then return end
	currentTab = tabName
	transitionID = transitionID + 1
	local currentID = transitionID
	
	tween(BlockTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(DashTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(MovesTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(PunchTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(MiscTabBtn, {0.3}, {TextColor3 = Color3.fromRGB(150,150,150)})
	tween(btn, {0.3}, {TextColor3 = Color3.new(1,1,1)})
	tween(TabIndicator, {0.3, Enum.EasingStyle.Back}, {Position = indicatorPos})
	ScrollContainer.CanvasSize = UDim2.new(0, 0, 0, contentHeight)
	
	animateOut(BlockPage); animateOut(DashPage); animateOut(MovesPage); animateOut(PunchPage); animateOut(MiscPage)
	
	if tabName == "Block" then animateIn(BlockPage)
	elseif tabName == "Dash" then animateIn(DashPage)
	elseif tabName == "Moves" then animateIn(MovesPage)
	elseif tabName == "Punch" then animateIn(PunchPage)
	elseif tabName == "Misc" then animateIn(MiscPage)
	end
	
	task.delay(0.4, function()
		if transitionID ~= currentID then return end
		BlockPage.Visible = (tabName == "Block")
		DashPage.Visible = (tabName == "Dash")
		MovesPage.Visible = (tabName == "Moves")
		PunchPage.Visible = (tabName == "Punch")
		MiscPage.Visible = (tabName == "Misc")
	end)
end

BlockTabBtn.MouseButton1Click:Connect(function() switchTab("Block", BlockTabBtn, UDim2.new(0, 2, 1, -3), TAB_HEIGHTS.Block) end)
DashTabBtn.MouseButton1Click:Connect(function() switchTab("Dash", DashTabBtn, UDim2.new(0.2, 2, 1, -3), TAB_HEIGHTS.Dash) end)
MovesTabBtn.MouseButton1Click:Connect(function() switchTab("Moves", MovesTabBtn, UDim2.new(0.4, 2, 1, -3), TAB_HEIGHTS.Moves) end)
PunchTabBtn.MouseButton1Click:Connect(function() switchTab("Punch", PunchTabBtn, UDim2.new(0.6, 2, 1, -3), TAB_HEIGHTS.Punch) end)
MiscTabBtn.MouseButton1Click:Connect(function() switchTab("Misc", MiscTabBtn, UDim2.new(0.8, 2, 1, -3), TAB_HEIGHTS.Misc) end)

-- =================================================================================
-- 6. TOGGLE LOGIC
-- =================================================================================

local settings = {
	Block = {Enabled = true, Look = false, Move = false, Caution = false},
	Dash = {Enabled = true, Look = false, Move = false, Smart = false},
	Moves = {Enabled = true, NailBlock = false}, 
	Punch = {Enabled = false, Look = false, Glide = false, Max3 = false},
	Misc = {SideDash = false, CamLock = false, Blatant = false}
}

local function updateToggleVisuals(btn, enabled, textOn, textOff)
	local newColor = enabled and Color3.fromRGB(50, 150, 80) or Color3.fromRGB(180, 60, 60)
	btn.Text = enabled and textOn or textOff
	btn:SetAttribute("BaseColor", newColor) 
	tween(btn, {0.2}, {BackgroundColor3 = newColor})
end

-- Block
B_Toggle.MouseButton1Click:Connect(function() settings.Block.Enabled = not settings.Block.Enabled; updateToggleVisuals(B_Toggle, settings.Block.Enabled, "Block: ON", "Block: OFF") end)
B_LookToggle.MouseButton1Click:Connect(function() settings.Block.Look = not settings.Block.Look; updateToggleVisuals(B_LookToggle, settings.Block.Look, "Look At: ON", "Look At: OFF") end)
B_MoveToggle.MouseButton1Click:Connect(function() settings.Block.Move = not settings.Block.Move; updateToggleVisuals(B_MoveToggle, settings.Block.Move, "Auto Pos: ON", "Auto Pos: OFF") end)
B_CautionToggle.MouseButton1Click:Connect(function() settings.Block.Caution = not settings.Block.Caution; updateToggleVisuals(B_CautionToggle, settings.Block.Caution, "Cautious: ON", "Cautious: OFF") end)

-- Dash
D_Toggle.MouseButton1Click:Connect(function() settings.Dash.Enabled = not settings.Dash.Enabled; updateToggleVisuals(D_Toggle, settings.Dash.Enabled, "Dash Block: ON", "Dash Block: OFF") end)
D_LookToggle.MouseButton1Click:Connect(function() settings.Dash.Look = not settings.Dash.Look; updateToggleVisuals(D_LookToggle, settings.Dash.Look, "Look At: ON", "Look At: OFF") end)
D_MoveToggle.MouseButton1Click:Connect(function() settings.Dash.Move = not settings.Dash.Move; updateToggleVisuals(D_MoveToggle, settings.Dash.Move, "Auto Pos: ON", "Auto Pos: OFF") end)
D_SmartToggle.MouseButton1Click:Connect(function() settings.Dash.Smart = not settings.Dash.Smart; updateToggleVisuals(D_SmartToggle, settings.Dash.Smart, "Smart Hold: ON", "Smart Hold: OFF") end)

-- Moves
SP_Toggle.MouseButton1Click:Connect(function() settings.Moves.Enabled = not settings.Moves.Enabled; updateToggleVisuals(SP_Toggle, settings.Moves.Enabled, "Move Block: ON", "Move Block: OFF") end)
N_Toggle.MouseButton1Click:Connect(function() settings.Moves.NailBlock = not settings.Moves.NailBlock; updateToggleVisuals(N_Toggle, settings.Moves.NailBlock, "Nail Block: ON", "Nail Block: OFF") end)

-- Punch
P_Toggle.MouseButton1Click:Connect(function() settings.Punch.Enabled = not settings.Punch.Enabled; updateToggleVisuals(P_Toggle, settings.Punch.Enabled, "Punch: ON", "Punch: OFF") end)
P_LookToggle.MouseButton1Click:Connect(function() settings.Punch.Look = not settings.Punch.Look; updateToggleVisuals(P_LookToggle, settings.Punch.Look, "Look At: ON", "Look At: OFF") end)
P_GlideToggle.MouseButton1Click:Connect(function() settings.Punch.Glide = not settings.Punch.Glide; updateToggleVisuals(P_GlideToggle, settings.Punch.Glide, "Glide: ON", "Glide: OFF") end)
P_ComboToggle.MouseButton1Click:Connect(function() settings.Punch.Max3 = not settings.Punch.Max3; updateToggleVisuals(P_ComboToggle, settings.Punch.Max3, "Max 3 Hits: ON", "Max 3 Hits: OFF") end)

-- Misc
M_SideDashToggle.MouseButton1Click:Connect(function() settings.Misc.SideDash = not settings.Misc.SideDash; updateToggleVisuals(M_SideDashToggle, settings.Misc.SideDash, "Side Dash: ON", "Side Dash: OFF") end)
M_CamLockToggle.MouseButton1Click:Connect(function() settings.Misc.CamLock = not settings.Misc.CamLock; updateToggleVisuals(M_CamLockToggle, settings.Misc.CamLock, "Cam Lock: ON", "Cam Lock: OFF") end)
M_BlatantToggle.MouseButton1Click:Connect(function() settings.Misc.Blatant = not settings.Misc.Blatant; updateToggleVisuals(M_BlatantToggle, settings.Misc.Blatant, "Blatant: ON", "Blatant: OFF") end)

-- =================================================================================
-- 7. LOGIC
-- =================================================================================

local isBlocking = false
local isAttacking = false
local blockTask = nil 
local lookAtActive = false
local lookAtEndTime = 0
local currentlyDashing = false
local dashTarget = nil
local lastSideDashTime = 0

local function isRagdolled(char)
	if not char then return false end
	local comp = char:FindFirstChild("RagdollComponents")
	if not comp then return false end
	local total, active = 0, 0
	for _, child in pairs(comp:GetChildren()) do
		if child:IsA("BallSocketConstraint") then
			total = total + 1
			if child.Enabled then active = active + 1 end
		end
	end
	return total > 0 and (active / total) > 0.5
end

local function areWelded(myChar, targetChar)
	if not myChar or not targetChar then return false end
	local myRoot = myChar:FindFirstChild("HumanoidRootPart")
	if not myRoot then return false end
	for _, part in pairs(myRoot:GetConnectedParts(true)) do
		if part.Parent == targetChar or part.Parent.Parent == targetChar then return true end
	end
	local hum = myChar:FindFirstChild("Humanoid")
	if hum and (hum.Sit or hum:GetState() == Enum.HumanoidStateType.PlatformStanding) then return true end
	return false
end

-- Checks if char is doing a counter
local function isCountering(char)
	local animator = char:FindFirstChild("Animator", true)
	if not animator then return false end
	for _, t in pairs(animator:GetPlayingAnimationTracks()) do
		local id = string.match(t.Animation.AnimationId, "%d+")
		if counterAnims[id] then return true end
	end
	return false
end

local function getSafeLookCFrame(originPos, targetPos)
	local flatOrigin = Vector3.new(originPos.X, 0, originPos.Z)
	local flatTarget = Vector3.new(targetPos.X, 0, targetPos.Z)
	if (flatTarget - flatOrigin).Magnitude < 2 then return nil end 
	return CFrame.lookAt(flatOrigin, flatTarget)
end

local function addCharToCache(char)
	if not table.find(activeCharacters, char) then table.insert(activeCharacters, char) end
end
local function removeCharFromCache(char)
	local idx = table.find(activeCharacters, char)
	if idx then table.remove(activeCharacters, idx) end
end

-- Optimized Nail Detection
local function registerNail(obj)
	if obj.Name == "Nail" and obj:IsA("Model") then
		table.insert(activeNails, obj)
		obj.AncestryChanged:Connect(function(_, parent)
			if not parent then
				local idx = table.find(activeNails, obj)
				if idx then table.remove(activeNails, idx) end
			end
		end)
	end
end
Workspace.DescendantAdded:Connect(registerNail)
for _, v in pairs(Workspace:GetDescendants()) do registerNail(v) end

local function getPredictedPos(char, predictionTime)
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return Vector3.zero end
	return root.Position + (root.Velocity * predictionTime)
end

local function isNearbyPredicted(char, maxDist, predictionTime)
	if not Player.Character then return false end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return false end
	local targetPos = getPredictedPos(char, predictionTime)
	return (myRoot.Position - targetPos).Magnitude <= maxDist
end

local function triggerSideDash(target)
	if isRagdolled(Player.Character) then return end
	local char = Player.Character
	local root = char:FindFirstChild("HumanoidRootPart")
	local hum = char:FindFirstChild("Humanoid")
	local animator = hum and hum:FindFirstChild("Animator")
	
	if not root or not hum or not animator then return end
	if hum.WalkSpeed < 1 then return end 
	
	local cooldown = tonumber(M_DashCD.Text) or 2
	if os.clock() - lastSideDashTime < cooldown then return end
	lastSideDashTime = os.clock()
	
	currentlyDashing = true
	dashTarget = target
	local isRight = math.random() > 0.5
	local dirMultiplier = isRight and 1 or -1
	local track = animator:LoadAnimation(isRight and dashAnimRight or dashAnimLeft)
	track:Play()
	
	local speed = tonumber(M_DashSpeed.Text) or 100
	local duration = tonumber(M_DashDecay.Text) or 0.3
	local startTime = os.clock()
	
	local connection
	connection = RunService.Heartbeat:Connect(function()
		if hum.WalkSpeed < 1 then
			if connection then connection:Disconnect() end
			currentlyDashing = false
			dashTarget = nil
			return
		end
		local elapsed = os.clock() - startTime
		if elapsed >= duration or not root.Parent then
			if connection then connection:Disconnect() end
			currentlyDashing = false
			dashTarget = nil
			root.AssemblyLinearVelocity = Vector3.new(0, root.AssemblyLinearVelocity.Y, 0)
			return
		end
		local alpha = elapsed / duration
		local currentSpeed = speed * (1 - (alpha * 0.7)) 
		local rightDir = root.CFrame.RightVector
		local oldVel = root.AssemblyLinearVelocity
		root.AssemblyLinearVelocity = (rightDir * currentSpeed * dirMultiplier) + Vector3.new(0, oldVel.Y, 0)
	end)
end

local function triggerGlide(targetChar)
	if not settings.Punch.Glide or isRagdolled(Player.Character) then return end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
	if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
	
	if settings.Misc.Blatant then
		local predTime = 0.1 
		local predPos = getPredictedPos(targetChar, predTime)
		local direction = (myRoot.Position - predPos).Unit
		local teleportPos = predPos + (direction * 3) 
		local safeLook = getSafeLookCFrame(teleportPos, predPos)
		if safeLook then
			local finalCF = safeLook + Vector3.new(0, myRoot.Position.Y, 0)
			myRoot.CFrame = finalCF 
		end
		return
	end
	
	local dist = (myRoot.Position - targetRoot.Position).Magnitude
	if dist > 3 and dist < 20 then
		local alpha = 0.3
		local newPos = myRoot.Position:Lerp(targetRoot.Position, alpha)
		local finalCF = getSafeLookCFrame(newPos, targetRoot.Position)
		if not finalCF then return end
		finalCF = finalCF + Vector3.new(0, myRoot.Position.Y, 0)
		TweenService:Create(myRoot, TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = finalCF}):Play()
	end
end

local function triggerBlockGlide(targetChar, pred)
	if not Player.Character then return end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetChar and targetChar:FindFirstChild("HumanoidRootPart")
	if not myRoot or not targetRoot or areWelded(Player.Character, targetChar) then return end
	
	local targetPos = getPredictedPos(targetChar, pred or 0)
	local direction = (myRoot.Position - targetPos).Unit
	local finalPos = targetPos + (direction * 3)
	
	if settings.Misc.Blatant then
		local safeLook = getSafeLookCFrame(finalPos, targetPos)
		if safeLook then myRoot.CFrame = safeLook + Vector3.new(0, myRoot.Position.Y, 0) end
		return
	end
	
	local safeLook = getSafeLookCFrame(finalPos, targetPos)
	if safeLook then
		safeLook = safeLook + Vector3.new(0, myRoot.Position.Y, 0)
		TweenService:Create(myRoot, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {CFrame = safeLook}):Play()
	end
end

local function activateLookAt(duration)
	if isRagdolled(Player.Character) then return end
	lookAtEndTime = os.clock() + duration
	lookAtActive = true
end

local function attemptPunch(targetChar)
	if isAttacking or isRagdolled(Player.Character) then return end
	if isRagdolled(targetChar) then return end 
	if settings.Punch.Max3 and comboCooldownActive then return end 
	
	-- Anti-Counter Check
	local anyCounter = false
	for _, char in pairs(activeCharacters) do
		if isNearbyPredicted(char, 15, 0) and isCountering(char) then anyCounter = true break end
	end
	if anyCounter then return end
	
	local chance = tonumber(P_Chance.Text) or 1
	if math.random() > chance then return end
	
	local delay = tonumber(P_Delay.Text) or 0.05
	local hold = tonumber(P_Hold.Text) or 0.1
	isAttacking = true
	
	task.delay(delay, function()
		if isRagdolled(Player.Character) then isAttacking = false return end
		sendRemote("M1", true)
		if settings.Punch.Look then
			local lookDuration = tonumber(P_LookTime.Text) or 0.35
			activateLookAt(lookDuration)
		end
		if targetChar then triggerGlide(targetChar) end
		StatusLabel.Text = "ATTACKING"
		StatusLabel.TextColor3 = Color3.fromRGB(255, 100, 100)
		task.delay(hold, function()
			sendRemote("M1", false)
			StatusLabel.Text = "IDLE"
			StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
			isAttacking = false
		end)
	end)
end

-- GENERIC BLOCK TRIGGER
local function triggerGenericBlock(targetChar, type, trackObj, specialData)
	if isRagdolled(Player.Character) then return end
	
	local cfg = {}
	if type == "Dash" then
		cfg = {
			Delay = tonumber(D_Delay.Text), Hold = tonumber(D_Hold.Text),
			Look = settings.Dash.Look, Move = settings.Dash.Move,
			PreDelay = tonumber(D_PreDelay.Text), LookTime = tonumber(D_LookTime.Text),
			Smart = settings.Dash.Smart, PostDelay = tonumber(D_PostDelay.Text), Pred = tonumber(D_Pred.Text)
		}
	elseif type == "Special" then
		local exDelay = tonumber(SP_ExDelay.Text) or 0
		local exHold = tonumber(SP_ExHold.Text) or 0
		cfg = {
			Delay = specialData.D + exDelay, Hold = specialData.H + exHold,
			Look = true, Move = false, 
			PreDelay = 0.05, LookTime = (specialData.H + exHold) + 0.5,
			Smart = false, Pred = 0 
		}
	else 
		cfg = {
			Delay = tonumber(B_Delay.Text), Hold = tonumber(B_Hold.Text),
			Look = settings.Block.Look, Move = settings.Block.Move,
			PreDelay = tonumber(B_PreDelay.Text), LookTime = tonumber(B_LookTime.Text),
			Smart = false, Pred = tonumber(B_Pred.Text)
		}
	end
	
	if type == "M1" and trackObj then
		local id = string.match(trackObj.Animation.AnimationId, "%d+")
		if m1Exceptions[id] then
			cfg.Delay = math.max(0, cfg.Delay + m1Exceptions[id])
		end
	end
	
	task.delay(cfg.Delay or 0.16, function()
		if isRagdolled(Player.Character) then return end
		if cfg.Move then triggerBlockGlide(targetChar, cfg.Pred) end
		
		if not isBlocking then
			isBlocking = true
			sendRemote("Block", true)
			StatusLabel.Text = (type == "Dash" and "DASH BLOCK") or (type == "Special" and "MOVE BLOCK") or "BLOCKING"
			StatusLabel.TextColor3 = Color3.fromRGB(80, 255, 120)
		end
		
		if blockTask then task.cancel(blockTask) end
		
		if cfg.Smart and type == "Dash" then
			StatusLabel.Text = "WAITING END"
			local animator = targetChar:FindFirstChild("Animator", true)
			local endAnimTrack = nil
			
			if animator then
				for _, t in pairs(animator:GetPlayingAnimationTracks()) do
					local id = string.match(t.Animation.AnimationId, "%d+")
					if dashEnds[id] then endAnimTrack = t break end
				end
				if not endAnimTrack then
					local connection
					connection = animator.AnimationPlayed:Connect(function(t)
						local id = string.match(t.Animation.AnimationId, "%d+")
						if dashEnds[id] then endAnimTrack = t connection:Disconnect() end
					end)
					local timeout = 0
					while not endAnimTrack and timeout < 1.5 do
						timeout = timeout + RunService.Heartbeat:Wait()
					end
					if connection then connection:Disconnect() end
				end
			end
			
			task.wait(cfg.PostDelay or 0.1)
			sendRemote("Block", false)
			isBlocking = false
			blockTask = nil
			StatusLabel.Text = "IDLE"
			StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
			
			if settings.Punch.Enabled and not isRagdolled(targetChar) then
				if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then attemptPunch(targetChar) end
			end
		else
			blockTask = task.delay(cfg.Hold or 0.12, function()
				sendRemote("Block", false)
				isBlocking = false
				blockTask = nil
				StatusLabel.Text = "IDLE"
				StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
				if settings.Punch.Enabled and not isRagdolled(targetChar) then
					if isNearbyPredicted(targetChar, tonumber(P_Dist.Text) or 5, 0) then attemptPunch(targetChar) end
				end
			end)
		end
	end)
	
	if cfg.Look then
		local lookStartDelay = math.max(0, (cfg.Delay or 0.16) - (cfg.PreDelay or 0.05))
		task.delay(lookStartDelay, function()
			if areWelded(Player.Character, targetChar) then return end
			activateLookAt(cfg.LookTime or 0.5)
		end)
	end
end

local function hookAnimator(animator, char)
	animator.AnimationPlayed:Connect(function(track)
		if isRagdolled(Player.Character) then return end
		if not track.Animation then return end
		if char == Player.Character then return end
		local rawId = string.match(track.Animation.AnimationId, "%d+")
		
		if settings.Block.Enabled and m1Database[rawId] and not processedTracks[track] then
			local chance = tonumber(B_Chance.Text) or 1
			if math.random() > chance then return end
			local pred = tonumber(B_Pred.Text) or 0
			local reqDist = tonumber(B_Dist.Text) or 10
			if isNearbyPredicted(char, reqDist, pred) then
				processedTracks[track] = true
				track.Ended:Connect(function() processedTracks[track] = nil end)
				triggerGenericBlock(char, "M1", track)
			end
		end
		
		if settings.Dash.Enabled and dashStarts[rawId] and not processedTracks[track] then
			local chance = tonumber(D_Chance.Text) or 1
			if math.random() > chance then return end
			local pred = tonumber(D_Pred.Text) or 0
			local reqDist = tonumber(D_Dist.Text) or 10
			if isNearbyPredicted(char, reqDist, pred) then
				processedTracks[track] = true
				track.Ended:Connect(function() processedTracks[track] = nil end)
				triggerGenericBlock(char, "Dash", track)
			end
		end
		
		if settings.Moves.Enabled and specialMovesDatabase[rawId] and not processedTracks[track] then
			local reqDist = tonumber(SP_Dist.Text) or 15
			if isNearbyPredicted(char, reqDist, 0) then
				processedTracks[track] = true
				track.Ended:Connect(function() processedTracks[track] = nil end)
				triggerGenericBlock(char, "Special", track, specialMovesDatabase[rawId])
			end
		end
	end)
end

local function hookLocalCharacter(char)
	local hum = char:WaitForChild("Humanoid", 5)
	local animator = hum and hum:WaitForChild("Animator", 5)
	if not animator then return end
	animator.AnimationPlayed:Connect(function(track)
		if not track.Animation then return end
		local rawId = string.match(track.Animation.AnimationId, "%d+")
		if settings.Punch.Max3 and m1Database[rawId] then
			if os.clock() - lastLocalPunchTime > 1.5 then localComboCount = 0 end
			localComboCount = localComboCount + 1
			lastLocalPunchTime = os.clock()
			if localComboCount >= 3 then
				comboCooldownActive = true
				StatusLabel.Text = "COMBO COOLDOWN"
				StatusLabel.TextColor3 = Color3.fromRGB(255, 150, 50)
				local cdTime = tonumber(P_ComboReset.Text) or 2
				task.delay(cdTime, function()
					comboCooldownActive = false
					localComboCount = 0
					StatusLabel.Text = "IDLE"
					StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
				end)
			end
		end
	end)
end

local function hookCharacter(char)
	if not char then return end
	addCharToCache(char)
	if char == Player.Character then hookLocalCharacter(char) return end
	local humanoid = char:FindFirstChild("Humanoid") or char:FindFirstChild("AnimationController")
	if not humanoid then humanoid = char:WaitForChild("Humanoid", 5) end
	if not humanoid then return end
	if humanoid:IsA("Humanoid") then humanoid.Died:Connect(function() removeCharFromCache(char) end) end
	char.AncestryChanged:Connect(function(_, parent) if not parent then removeCharFromCache(char) end end)
	local animator = humanoid:FindFirstChild("Animator")
	if not animator then animator = humanoid:WaitForChild("Animator", 5) end
	if not animator then return end
	hookAnimator(animator, char)
end

RunService.Heartbeat:Connect(function()
	if isRagdolled(Player.Character) then return end
	if not Player.Character then return end
	for _, char in pairs(activeCharacters) do
		if char ~= Player.Character and char.Parent then
			local animator = char:FindFirstChild("Animator", true)
			if animator then
				for _, track in pairs(animator:GetPlayingAnimationTracks()) do
					local id = string.match(track.Animation.AnimationId, "%d+")
					if not processedTracks[track] then
						if settings.Block.Enabled and m1Database[id] then
							local pred = tonumber(B_Pred.Text) or 0
							local reqDist = tonumber(B_Dist.Text) or 10
							if isNearbyPredicted(char, reqDist, pred) then
								processedTracks[track] = true
								track.Ended:Connect(function() processedTracks[track] = nil end)
								triggerGenericBlock(char, "M1", track)
							end
						elseif settings.Dash.Enabled and dashStarts[id] then
							local pred = tonumber(D_Pred.Text) or 0
							local reqDist = tonumber(D_Dist.Text) or 10
							if isNearbyPredicted(char, reqDist, pred) then
								processedTracks[track] = true
								track.Ended:Connect(function() processedTracks[track] = nil end)
								triggerGenericBlock(char, "Dash", track)
							end
						elseif settings.Moves.Enabled and specialMovesDatabase[id] then
							local reqDist = tonumber(SP_Dist.Text) or 15
							if isNearbyPredicted(char, reqDist, 0) then
								processedTracks[track] = true
								track.Ended:Connect(function() processedTracks[track] = nil end)
								triggerGenericBlock(char, "Special", track, specialMovesDatabase[id])
							end
						end
					end
				end
			end
		end
	end
	
	if settings.Moves.NailBlock then
		local dist = tonumber(N_Dist.Text) or 40
		local nailThreat = false
		local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
		if myRoot then
			for _, obj in pairs(activeNails) do
				if obj.Parent then
					if obj:IsDescendantOf(Player.Character) then continue end -- Own nail
					local creator = obj:FindFirstChild("Creator")
					if creator and creator.Value == Player then continue end -- Own projectile
					
					local prim = obj.PrimaryPart or obj:FindFirstChild("HumanoidRootPart") or obj:FindFirstChildOfClass("Part")
					if prim and (prim.Position - myRoot.Position).Magnitude < dist then
						nailThreat = true
						break
					end
				end
			end
			
			if nailThreat then
				if not isBlocking then
					isBlocking = true
					sendRemote("Block", true)
					StatusLabel.Text = "NAIL BLOCK"
					StatusLabel.TextColor3 = Color3.fromRGB(255, 50, 50)
				end
				if blockTask then task.cancel(blockTask) end
				blockTask = task.delay(0.2, function()
					if not isBlocking then return end
					sendRemote("Block", false)
					isBlocking = false
					blockTask = nil
					StatusLabel.Text = "IDLE"
					StatusLabel.TextColor3 = Color3.fromRGB(100, 100, 100)
				end)
			end
		end
	end
end)

task.spawn(function()
	while task.wait(1) do
		if not settings.Block.Caution or isRagdolled(Player.Character) or isBlocking then continue end
		local rate = tonumber(B_CautionRate.Text) or 0.05
		if math.random() > rate then continue end
		local dist = tonumber(B_CautionDist.Text) or 15
		local target = nil
		for _, char in pairs(activeCharacters) do
			if isNearbyPredicted(char, dist, 0) then target = char break end
		end
		if target then
			activateLookAt(0.5)
			sendRemote("Block", true)
			task.wait(0.2)
			sendRemote("Block", false)
		end
	end
end)

RunService.Heartbeat:Connect(function()
	if settings.Block.Enabled then return end 
	if not settings.Punch.Enabled or isRagdolled(Player.Character) then return end
	if not Player.Character then return end
	local atkDist = tonumber(P_Dist.Text) or 5
	local lookDist = tonumber(P_LookDist.Text) or 15
	local foundTarget = nil
	if currentlyDashing and dashTarget and dashTarget.Parent and isNearbyPredicted(dashTarget, lookDist, 0) then
		foundTarget = dashTarget
	else
		for _, char in pairs(activeCharacters) do
			if char ~= Player.Character and char.Parent then
				if isNearbyPredicted(char, lookDist, 0) then foundTarget = char break end
			end
		end
	end
	if foundTarget then
		if isNearbyPredicted(foundTarget, atkDist, 0) then
			attemptPunch(foundTarget)
			if settings.Misc.SideDash then triggerSideDash(foundTarget) end
		elseif settings.Punch.Look then
			activateLookAt(0.1) 
		end
	end
end)

RunService.RenderStepped:Connect(function()
	if settings.Misc.CamLock then
		local camTarget = nil
		if currentlyDashing and dashTarget and dashTarget.Parent then camTarget = dashTarget
		else
			local closestDist = 100
			for _, char in pairs(activeCharacters) do
				if char ~= Player.Character and char.Parent then
					local targetRoot = char:FindFirstChild("HumanoidRootPart")
					if targetRoot and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
						local dist = (Player.Character.HumanoidRootPart.Position - targetRoot.Position).Magnitude
						if dist < closestDist then closestDist = dist camTarget = char end
					end
				end
			end
		end
		if camTarget and camTarget:FindFirstChild("HumanoidRootPart") then
			local cam = Workspace.CurrentCamera
			local smooth = tonumber(M_CamSmooth.Text) or 0.1
			local targetPos = camTarget.HumanoidRootPart.Position
			
			if settings.Misc.Blatant then
				local lookVec = (targetPos - cam.CFrame.Position).Unit
				local _, _, roll = cam.CFrame:ToOrientation()
				local yaw = math.atan2(-lookVec.X, -lookVec.Z)
				local pitch = math.asin(lookVec.Y)
				cam.CFrame = CFrame.new(cam.CFrame.Position) * CFrame.fromOrientation(pitch, yaw, roll)
			else
				local lookVec = (targetPos - cam.CFrame.Position).Unit
				local yaw = math.atan2(-lookVec.X, -lookVec.Z)
				local rx, _, rz = cam.CFrame:ToOrientation()
				local goalCF = CFrame.new(cam.CFrame.Position) * CFrame.fromOrientation(rx, yaw, rz)
				cam.CFrame = cam.CFrame:Lerp(goalCF, smooth)
			end
		end
	end

	if (not lookAtActive and not currentlyDashing) or isRagdolled(Player.Character) then return end
	if not currentlyDashing and os.clock() > lookAtEndTime then lookAtActive = false return end
	if not Player.Character then return end
	local myRoot = Player.Character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return end
	local targetChar = nil
	if currentlyDashing and dashTarget and dashTarget.Parent then targetChar = dashTarget
	else
		local closestDist = 50 
		for _, char in pairs(activeCharacters) do
			if char ~= Player.Character and char.Parent then
				if areWelded(Player.Character, char) then continue end 
				local targetRoot = char:FindFirstChild("HumanoidRootPart")
				if targetRoot then
					local dist = (myRoot.Position - targetRoot.Position).Magnitude
					if dist < closestDist then closestDist = dist targetChar = char end
				end
			end
		end
	end
	if targetChar then
		local targetPos = targetChar.HumanoidRootPart.Position
		local safeCF = getSafeLookCFrame(myRoot.Position, targetPos)
		if safeCF then
			local goalCF = safeCF + Vector3.new(0, myRoot.Position.Y, 0)
			if currentlyDashing or settings.Misc.Blatant then myRoot.CFrame = goalCF
			else myRoot.CFrame = myRoot.CFrame:Lerp(goalCF, 0.3) end
		end
	end
end)

if Player.Character then hookCharacter(Player.Character) end
Player.CharacterAdded:Connect(hookCharacter)

for _, desc in pairs(Workspace:GetDescendants()) do
	if desc:IsA("Model") and desc:FindFirstChild("Humanoid") then task.spawn(function() hookCharacter(desc) end) end
end
Workspace.DescendantAdded:Connect(function(desc)
	if desc:IsA("Model") and desc:FindFirstChild("Humanoid") then hookCharacter(desc) end
end)
